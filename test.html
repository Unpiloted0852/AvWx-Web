<!DOCTYPE html>
<html lang="en" class="h-full antialiased">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="light dark">
    
<link rel="icon" href="./favicon.ico">
<link rel="apple-touch-icon" href='./apple-touch-icon.png'>


    <title>Aviation Weather Report (TAF & METAR)</title>

    <script>
        // Map Tile URLs
        const MAP_DARK_URL = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
        const MAP_LIGHT_URL = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

        // Global reference to tile layer for updating
        let tileLayer = null;
        let showRunwaysOnMap = true;

        // Check local storage or system preference
        function getInitialTheme() {
            try {
                if ('theme' in localStorage) {
                    return localStorage.theme;
                }
            } catch (e) {
                console.log("LocalStorage access denied");
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function applyTheme(theme) {
            // Toggle Tailwind class on HTML element
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }

            // Toggle Flatpickr Theme Manually (if loaded)
            const flatpickrDark = document.getElementById('flatpickr-dark-css');
            if (flatpickrDark) {
                flatpickrDark.disabled = (theme !== 'dark');
            }

            // Toggle Map Tiles if map exists
            if (tileLayer) {
                tileLayer.setUrl(theme === 'dark' ? MAP_DARK_URL : MAP_LIGHT_URL);
            }
        }

        // This function is called directly by the button onclick
        function toggleTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            const newTheme = isDark ? 'light' : 'dark';
            applyTheme(newTheme);
            try {
                localStorage.setItem('theme', newTheme);
            } catch(e) {
                console.warn("Could not save theme to localStorage", e);
            }
        }

        // Apply immediately on load
        applyTheme(getInitialTheme());

document.addEventListener('DOMContentLoaded', () => {
     applyTheme(getInitialTheme());
     
     // NEW: Sync button state
     if (showRunwaysOnMap) {
         const btn = document.getElementById('runwayMapBtn');
         if (btn) btn.classList.add('runway-active');
     }
});
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link id="flatpickr-dark-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/dark.css" disabled>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <!-- Leaflet Map Library -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    
    /* ADS-B Active State */
/* ADS-B Active State */
.traffic-active {
    background-color: #10b981 !important;
    color: white !important;
}

/* Compact Traffic Popup Override */
.traffic-popup-compact .leaflet-popup-content-wrapper {
    padding: 0;
    overflow: hidden;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.95);
    /* CRITICAL: Override global min-width */
    min-width: 0px !important; 
    width: auto !important;
}

.dark .traffic-popup-compact .leaflet-popup-content-wrapper {
    background: rgba(30, 41, 59, 0.95);
    border: 1px solid #374151;
}

.traffic-popup-compact .leaflet-popup-content {
    margin: 0 !important;
    width: auto !important;
    min-width: 120px !important; /* Small but readable */
}

.traffic-popup-compact .leaflet-popup-tip {
    background: rgba(255, 255, 255, 0.95);
}
.dark .traffic-popup-compact .leaflet-popup-tip {
    background: #374151;
}

/* ATC VISUAL STYLE - UPDATED */
.atc-container {
    position: relative;
    width: 100%;
    height: 100%;
    pointer-events: auto; 
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8));
}

/* The Target Blip (Triangle) */
.atc-blip {
    position: absolute;
    top: 0; left: 0;
    width: 12px; 
    height: 12px;
    background-color: #10b981; /* Emerald-500 */
    /* Sharp triangle */
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    transition: transform 1s linear;
}

/* The Data Block (Label) */
.atc-label {
    position: absolute;
    left: 10px; /* Hugs the right side of the blip */
    top: -3px;  /* Aligned with top of blip */
    
    font-family: 'JetBrains Mono', 'Courier New', monospace;
    font-size: 9px;
    font-weight: 700;
    line-height: 1.0; 
    color: #10b981; 
    
    text-shadow: 
        -1px -1px 0 #000,  
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000,
         0px 0px 2px #000;
         
    white-space: nowrap; /* CRITICAL FIX: Prevents code indentation from becoming visual space */
    pointer-events: none;
    z-index: 20;
}

/* Secondary Info Row (Alt/Speed) */
.atc-label span {
    display: block;
    opacity: 0.9;
    font-size: 8px;
    margin-top: 0px; 
}
    
    /* Premium Dashboard Styling */
.dash-card {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.15);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.dark .dash-card {
    background-color: rgba(30, 41, 59, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.dash-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.25);
}

/* Specific Category Glows (Subtle) */
.vfr-glow { border-top: 4px solid #22c55e; }
.mvfr-glow { border-top: 4px solid #3b82f6; }
.ifr-glow { border-top: 4px solid #ef4444; }
.lifr-glow { border-top: 4px solid #ec4899; }
.nodata-glow { border-top: 4px solid #9ca3af; }
        /* CRITICAL FIX: Ensure padding is included in width calculations */
        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: #e5e7eb; }

        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .font-mono { font-family: 'JetBrains Mono', 'Courier New', monospace; }

        /* Custom styles for the colored legend dots */
        .weather-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 4px;
            flex-shrink: 0;
        }

        /* Weather Colors */
        .vfr-dot { background-color: rgb(0, 170, 0); }
        .mvfr-dot { background-color: #2563eb; }
        .ifr-dot { background-color: rgb(200, 0, 0); }
        .lifr-dot { background-color: rgb(255, 20, 147); }

        /* Advanced Tab Tiles */
        .vfr-tile { background-color: rgb(0, 170, 0); }
        .mvfr-tile { background-color: #2563eb; }
        .ifr-tile { background-color: rgb(200, 0, 0); }
        .lifr-tile { background-color: rgb(255, 20, 147); }
        .nodata-tile { background-color: rgb(150, 150, 150); }

        .flatpickr-calendar { font-family: 'Inter', sans-serif; }

        /* Leaflet Dark Theme Overrides */
        .leaflet-container { font-family: 'Inter', sans-serif; background: #e5e7eb; }
        .dark .leaflet-container { background: #111; }

       /* Ensure interactivity for vectors */
.leaflet-interactive { cursor: pointer; }

        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background-color: #ffffff; /* Default Light Mode */
            color: #1f2937;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            min-width: 300px;
        }

        /* Dark Mode Popup Overrides */
        .dark .leaflet-popup-content-wrapper, .dark .leaflet-popup-tip {
            background-color: #1f2937;
            color: #f3f4f6;
            border-color: #374151;
        }

        .leaflet-popup-content { margin: 12px; line-height: 1.5; min-width: 280px; max-height: 300px; overflow-y: auto; }
        .leaflet-container a.leaflet-popup-close-button { color: #9ca3af; padding: 8px; }
        .leaflet-container a.leaflet-popup-close-button:hover { color: #000; }
        .dark .leaflet-container a.leaflet-popup-close-button:hover { color: #fff; }

        /* Minimize Leaflet Attribution (Bottom Right) */
        .leaflet-control-attribution {
            font-size: 7px !important;
            padding: 0 2px !important;
            margin: 0 !important;
            background: rgba(255, 255, 255, 0.4) !important;
            line-height: 1.1 !important;
            color: #666 !important;
        }
        .dark .leaflet-control-attribution {
            background: rgba(0, 0, 0, 0.4) !important;
            color: #888 !important;
        }
        .leaflet-control-attribution a {
            color: inherit !important;
            text-decoration: none !important;
        }

        /* Map container height */
        #weatherMap { height: 100%; width: 100%; z-index: 0; }

        /* --- MAP STATES --- */

        /* 1. Embedded State (Default) */
        #mapView {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 400px;
            border-radius: 0.75rem;
            overflow: hidden;
            z-index: 0;
        }

        /* 2. Fullscreen State */
        #mapView.fullscreen-active {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100vw; height: 100dvh;
            z-index: 9999; /* Top level */
            border-radius: 0;
            background: #000;
        }

        body.map-mode { overflow: hidden; }

/* --- 1. FLOATING CONTROLS (Top Bar) --- */
        .map-overlay-top {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 1rem; z-index: 1000; pointer-events: none;
            display: flex; justify-content: center;
        }

        /* --- 2. MAP BUTTONS (GPS & FULLSCREEN) --- */
        .fullscreen-trigger, .gps-trigger {
            /* Define size locally for buttons */
            --btn-size: min(32px, 7vh);
            
            width: var(--btn-size) !important;
            height: var(--btn-size) !important;
            padding: 0 !important;
            
            display: flex;
            align-items: center;
            justify-content: center;
            
            position: absolute;
            right: 0.5rem !important;
            z-index: 1000;
            
            background-color: white;
            color: #374151;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .dark .fullscreen-trigger, .dark .gps-trigger {
            background-color: #1f2937;
            color: #e5e7eb;
        }

        .fullscreen-trigger {
            top: 0.5rem !important; 
        }

        .gps-trigger {
            /* Calculate top based on button size + gap */
            top: calc(0.5rem + var(--btn-size) + 6px) !important;
        }
        
        .fullscreen-trigger svg, .gps-trigger svg {
            width: 60% !important; height: 60% !important;
        }

        .gps-trigger {
            font-size: clamp(8px, 2vh, 10px) !important;
            font-weight: 900;
        }

        /* --- 3. LAYER MENU CONTAINER --- */
        .layer-menu-container {
            /* CRITICAL FIX: Define the variable here so the calc works */
            --btn-size: min(32px, 7vh);
            
            position: absolute;
            z-index: 1000;
            
            /* Calculate position: Top margin + 2 buttons + 2 gaps */
            top: calc(0.5rem + (var(--btn-size) * 2) + 12px) !important;
            
            right: 0.5rem !important;
            left: auto !important; 
            bottom: auto !important;
            
            display: flex;
            flex-direction: column; 
            align-items: flex-end;
            gap: min(4px, 1vh); 
            pointer-events: none; 
        }

        /* --- 4. LAYER MENU ITEMS LIST --- */
        .layer-items {
            display: flex;
            flex-direction: column; 
            gap: min(4px, 1vh); 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: translateY(-10px) scale(0.9);
            pointer-events: none;
            height: 0; 
            overflow: hidden;
            margin-top: 2px;
            max-height: calc(100vh - 12rem);
            overflow-y: auto; 
            padding-right: 2px;
        }
        
        .layer-items::-webkit-scrollbar { width: 0px; background: transparent; }

        .layer-menu-open .layer-items {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
            height: auto; 
            overflow: visible;
        }

        /* --- 5. LAYER BUTTONS --- */
        .layer-btn {
            --btn-size: min(32px, 7vh);
            
            width: var(--btn-size);
            height: var(--btn-size);
            
            display: flex;
            align-items: center;
            justify-content: center;
            
            border-radius: 8px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            pointer-events: auto;
            position: relative; 
            flex-shrink: 0;
        }

        .layer-btn:active { transform: scale(0.95); }

        .layer-btn svg { width: 60%; height: 60%; }

/* Text Scaling (RWY/ADS-B) */
        .layer-btn span, .layer-btn div { 
            /* Reduced min size slightly (7px) to fit "ADS-B" */
            font-size: clamp(7px, 2vh, 10px) !important; 
            font-weight: 900; 
            
            /* Force text onto one line */
            white-space: nowrap;
            
            /* Tighten letters slightly to fit */
            letter-spacing: -0.5px;
        }

        .layer-btn.text-xl, .layer-btn.text-lg { 
            font-size: clamp(12px, 3.5vh, 1.1rem) !important; 
        }

        /* --- 6. DESKTOP OVERRIDES --- */
        @media (min-width: 768px) {
            .fullscreen-trigger, .gps-trigger, .layer-btn {
                --btn-size: 44px; /* Fixed size on desktop */
                border-radius: 12px;
            }
            
            .fullscreen-trigger { top: 1rem !important; right: 1rem !important; }
            .gps-trigger { top: 4rem !important; right: 1rem !important; }
            
            .layer-menu-container {
                /* Fixed position on desktop, no calc needed */
                top: 7rem !important; 
                right: 1rem !important;
                gap: 12px;
            }
            
            .layer-items {
                gap: 10px;
                margin-top: 4px;
                max-height: none;
                overflow-y: visible;
            }
            
            .layer-btn svg { width: 24px; height: 24px; }
            .layer-btn.text-xl { font-size: 1.25rem !important; }
        }

        /* --- 6. DESKTOP OVERRIDES (MD BREAKPOINT) --- */
        @media (min-width: 768px) {
            /* Restore Standard Sizes */
            .fullscreen-trigger, .gps-trigger, .layer-btn {
                --btn-size: 44px;
                border-radius: 12px;
            }
            
            /* Restore Positioning */
            .fullscreen-trigger { top: 1rem !important; right: 1rem !important; }
            .gps-trigger { top: 4rem !important; right: 1rem !important; }
            
            .layer-menu-container {
                top: 7rem !important; 
                right: 1rem !important;
                gap: 12px;
            }
            
            .layer-items {
                gap: 10px;
                margin-top: 4px;
                max-height: none;
                overflow-y: visible;
            }
            
            .layer-btn svg { width: 24px; height: 24px; }
            .layer-btn.text-xl { font-size: 1.25rem !important; }
        }
        
        
        .dark .active-indicator { border-color: #1f2937; }
        .has-active-layers .active-indicator { display: block; }

/* Ensure Fullscreen button stays on top in fullscreen mode */
.fullscreen-trigger {
    z-index: 11000 !important; /* Higher than map overlay */
}

/* Logic to hide ADS-B Text Labels when specific class is added to map */
.hide-traffic-labels .atc-label {
    display: none !important;
}
/* Keep the blip visible, just hide the text */
.hide-traffic-labels .atc-blip {
    display: block !important;
}
        /* Heatmap Legend */
        #heatmapLegend {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            backdrop-filter: blur(4px);
            width: 240px;
        }
        .dark #heatmapLegend {
            background: rgba(30, 41, 59, 0.9);
            color: white;
        }

        .legend-labels {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
            font-size: 10px;
            font-family: monospace;
            font-weight: bold;
        }

        .floating-pill {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0,0,0,0.1);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border-radius: 9999px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .dark .floating-pill {
            background: rgba(30, 41, 59, 0.85);
            border-color: rgba(255,255,255,0.1); color: white;
        }

      /* Runway Active State (Matches Radar/Pirep style) */
.runway-active {
    background-color: #8b5cf6 !important; /* Violet-500 */
    color: white !important;
}

/* Radar Active State */
.radar-active {
    background-color: #3b82f6 !important;
    color: white !important;
}

        /* Freezing Active State */
        .freezing-active {
            background-color: #06b6d4 !important; /* Cyan-500 */
            color: white !important;
        }

        /* PIREP Active State */
        .pirep-active {
            background-color: #f59e0b !important; /* Amber-500 */
            color: white !important;
        }

        /* Hazard (SIGMET) Active State */
        .hazard-active {
            background-color: #ef4444 !important; /* Red-500 */
            color: white !important;
        }

        /* Day/Night Active State */
        .daynight-active {
            background-color: #4b5563 !important; /* Dark Gray */
            color: #fbbf24 !important; /* Amber for sun/moon */
        }

        /* GPS Status Text Style */
        .gps-active-input {
            color: #059669 !important; /* Emerald 600 */
            font-weight: 900 !important;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            font-size: 0.7rem !important; /* Smaller font for -GPS- */
            padding-top: 0.6rem !important;
        }
        .dark .gps-active-input {
            color: #34d399 !important; /* Emerald 400 */
        }

        /* --- MAP LABELS STYLING (Optimized for divIcon) --- */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }

        /* Custom PIREP Icon Container */
        .pirep-icon {
            /* Handled by Leaflet divIcon, essentially a wrapper for the SVG */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer !important;
            pointer-events: auto !important;
        }

        .map-icao-label {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 11px;
            text-align: center;
            text-shadow: 1.5px 1.5px 0 #fff, -1.5px -1.5px 0 #fff, 1.5px -1.5px 0 #fff, -1.5px 1.5px 0 #fff, 1.5px 1.5px 0 #fff;
            white-space: nowrap;
        }

        .dark .map-icao-label {
            text-shadow: 1.5px 1.5px 0 #000, -1.5px -1.5px 0 #000, 1.5px -1.5px 0 #000, -1.5px 1.5px 0 #000, 1.5px 1.5px 0 #000;
        }

        /* Label Colors matching dots */
        .label-vfr { color: rgb(0, 170, 0); }
        .label-mvfr { color: #2563eb; }
        .label-ifr { color: rgb(200, 0, 0); }
        .label-lifr { color: rgb(255, 20, 147); }
        .label-nodata { color: rgb(150, 150, 150); }

        /* Zulu Clock Overlay */
        #zuluClock {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 1100; /* High z-index to stay above maps */
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.8);
            color: #d97706; /* Amber-600 for light mode visibility */
            border: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            pointer-events: none; /* Let clicks pass through if needed */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .dark #zuluClock {
            background: rgba(0, 0, 0, 0.6);
            color: #fbbf24; /* Amber-400 */
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Radar Time Display */
        #radarTimeDisplay {
            position: absolute;
            top: 3.5rem;
            left: 1rem;
            z-index: 1100;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.8);
            color: #2563eb;
            border: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
            padding: 0.2rem 0.6rem;
            border-radius: 0.5rem;
            font-size: 0.65rem;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
            white-space: nowrap;
        }

        .dark #radarTimeDisplay {
            background: rgba(0, 0, 0, 0.6);
            color: #60a5fa; /* Light blue */
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* GPS Marker Pulse Animation */
        @keyframes pulse-blue {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { box-shadow: 0 0 0 25px rgba(59, 130, 246, 0); } /* Larger radius */
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }

        .user-location-marker {
            background-color: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            /* box-shadow removed here, handled by animation */
            animation: pulse-blue 2s infinite;
        }

        
/* Update Zulu Clock to be fixed globally */
#zuluClock {
    position: fixed;
    top: 0.75rem;
    left: 0.75rem;
    z-index: 110000; /* Higher than dashboard fullscreen */
    font-family: 'JetBrains Mono', monospace;
    font-weight: 700;
    background: rgba(255, 255, 255, 0.9);
    color: #d97706;
    border: 1px solid rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(4px);
    padding: 0.25rem 0.6rem;
    border-radius: 0.5rem;
    font-size: 0.75rem;
    pointer-events: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.dark #zuluClock {
    background: rgba(15, 23, 42, 0.9);
    color: #fbbf24;
    border-color: rgba(255, 255, 255, 0.1);
}

/* --- NATURAL SCROLLING DASHBOARD --- */
body.dashboard-active-mode {
    overflow-y: auto !important; /* Force browser scrollbar */
    height: auto !important;
}

/* 1. Un-constrain the main container */
body.dashboard-active-mode #resultsContainer {
    display: block !important;       /* Remove flex constraints */
    position: relative !important;
    height: auto !important;         /* Remove h-[85vh] */
    max-height: none !important;     /* Remove max-h constraints */
    width: 100% !important;
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
    overflow: visible !important;    /* Disable internal scrolling */
}

/* 2. Un-constrain the dashboard view itself */
body.dashboard-active-mode #customDashboardView {
    height: auto !important;
    overflow: visible !important;
    padding-bottom: 4rem; /* Space for footer/overscroll */
}

/* 3. Ensure the Sticky Header stays stuck to the browser window */
body.dashboard-active-mode #customDashboardView .sticky {
    position: sticky !important;
    top: 0 !important;
    z-index: 500 !important;
}

/* Keep Zulu clock on top of fullscreen */
#zuluClock {
    z-index: 100000 !important; 
}
        /* Tailwind utilities (Simulated) */
        .bg-gray-100 { background-color: #f3f4f6; }
        .dark .dark\:bg-black { background-color: #000000; }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gray-100 dark:bg-black text-gray-900 dark:text-gray-100 min-h-full antialiased transition-colors duration-300 overflow-x-hidden">

<div id="zuluClock">00:00:00Z</div>

<!-- Update Banner -->


<div id="updateBanner" class="hidden fixed top-0 left-0 right-0 z-[200000] p-4 bg-blue-600 text-white shadow-xl">
    <div class="container mx-auto max-w-5xl flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="flex items-center gap-3">
            <div class="bg-white/20 p-2 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
            </div>
            <div>
                <p class="font-bold text-lg">New Version Available!</p>
                <p class="text-blue-100 text-sm">Version <span id="newVersionTag"></span> is ready to download.</p>
            </div>
        </div>
        <div class="flex items-center gap-3 w-full sm:w-auto">
            <a id="downloadUpdateBtn" href="#" class="flex-1 sm:flex-none text-center bg-white text-blue-600 hover:bg-blue-50 font-bold py-2 px-6 rounded-lg transition-colors shadow-sm">
                Download Update
            </a>
            <button id="closeUpdateBanner" class="p-2 hover:bg-blue-700 rounded-lg transition-colors" aria-label="Close">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>
</div>

<!-- Records Modal -->
<div id="recordsModal" class="hidden fixed inset-0 z-[10000] flex items-center justify-center bg-black/60 backdrop-blur-md p-4 transition-opacity duration-300" onclick="closeRecordsModal()">
    <div class="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col border border-gray-200 dark:border-gray-800" onclick="event.stopPropagation()">
        
        <!-- Header -->
        <div class="p-6 border-b border-gray-200 dark:border-gray-800 flex justify-between items-center">
            <div>
                <h2 class="text-2xl font-black text-gray-900 dark:text-white flex items-center gap-2">
                    <span class="text-amber-500">üèÜ</span> Current Extremes
                </h2>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Scanned from <span id="recordsCount">0</span> stations</p>
            </div>
            <button onclick="closeRecordsModal()" class="p-2 bg-gray-100 dark:bg-gray-800 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
                <svg class="w-6 h-6 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
        </div>

        <!-- Content Grid -->
        <div class="p-6 overflow-y-auto bg-gray-50 dark:bg-black/20">
            <div id="recordsGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Cards injected via JS -->
            </div>
        </div>
    </div>
</div>

<!-- Modal Overlay for TAF Details (Increased Z-Index) -->
<div id="tileModal" class="hidden fixed inset-0 z-[10000] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4 transition-opacity duration-300" onclick="handleModalClick(event)">
    <div class="rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col modal-enter transition-all transform border-none" onclick="event.stopPropagation()">
        <!-- Content injected via JS -->
        <div id="modalContent"></div>
    </div>
</div>


 </div>

<!-- MAIN CONTAINER (Full Width) -->
<div class="w-full px-3 md:px-8 pt-4 mt-2 pb-8">

   <!-- TOP-RIGHT CONTROL ROW (Prevents overlapping) -->
<div class="z-[110] absolute top-0 right-0 md:top-4 flex items-center gap-2">
    <!-- 1. Dashboard -->
    <button id="dashboardBtn" type="button" onclick="openDashboard()" title="Dashboard"
        class="p-2 rounded-full w-10 h-10 flex items-center justify-center bg-indigo-600 text-white hover:bg-indigo-700 shadow-md transition-transform hover:scale-110 active:scale-95">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1H5a1 1 0 01-1-1v-4zM14 15a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
        </svg>
    </button>
    <!-- 2. Pressure -->
    <button id="pressureUnitToggleBtn" type="button" onclick="togglePressureUnits()"
        class="p-2 rounded-full w-14 h-10 flex items-center justify-center font-bold text-xs font-mono bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-700 shadow-sm transition-colors">
        inHg
    </button>
    <!-- 3. Temp -->
    <button id="unitToggleBtn" type="button" onclick="toggleUnits()"
        class="p-2 rounded-full w-10 h-10 flex items-center justify-center font-bold text-sm font-mono bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-700 shadow-sm transition-colors">
        ¬∞F
    </button>
    <!-- 4. Theme Toggle -->
    <button id="themeToggleBtn" type="button" onclick="toggleTheme()" aria-label="Toggle Dark Mode"
            class="p-2 rounded-full bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-700 shadow-sm cursor-pointer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
        </svg>
    </button>
    
    <!-- 5. Records / Extremes -->
<button onclick="showRecords()" title="Weather Records"
    class="p-2 rounded-full bg-amber-500 hover:bg-amber-600 text-white shadow-md transition-transform hover:scale-110 active:scale-95 flex items-center justify-center">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
    </svg>
</button>

</div>
        <header class="mb-6 text-center pt-12 md:pt-16">
            <h1 class="text-2xl md:text-3xl font-bold text-blue-600 dark:text-blue-400 flex justify-center items-center">
                Aviation Weather Report
                <span class="text-xs text-gray-400 dark:text-gray-500 font-normal ml-2 tracking-wide self-center" id="appVersionDisplay"></span>
            </h1>
            <p class="text-sm md:text-base text-gray-600 dark:text-gray-400 mt-2 px-4">
                Generates a report of current METARs and TAFs. Warning: this app should be considered experimental--use at your own risk!
            </p>
            <div class="flex justify-center flex-wrap gap-x-4 gap-y-2 mt-4 text-xs md:text-sm font-bold">
                <span class="flex items-center gap-1"><span class="weather-dot vfr-dot"></span>VFR</span>
                <span class="flex items-center gap-1"><span class="weather-dot mvfr-dot"></span>MVFR</span>
                <span class="flex items-center gap-1"><span class="weather-dot ifr-dot"></span>IFR</span>
                <span class="flex items-center gap-1"><span class="weather-dot lifr-dot"></span>LIFR</span>
                <span id="nodata-legend" class="flex items-center gap-1 text-gray-500" style="display: none;"><span class="weather-dot nodata-tile"></span>No TAF Data</span>
            </div>
        </header>

        <div class="bg-white dark:bg-black border border-transparent dark:border-gray-800 p-4 md:p-6 rounded-xl shadow-lg mb-6 transition-colors duration-300">
            <!-- Input fields -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

                <div class="md:col-span-1 flex flex-col justify-end">
                    <div class="grid grid-cols-2 gap-3">
                        <div class="p-3 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-800">
                            <label for="icaoInput" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">
                                Home Airport
                            </label>
                            <div class="flex w-full h-10 shadow-sm">
                                <input type="text" id="icaoInput" maxlength="9" placeholder="KOKC" onfocus="handleInputFocus(this)"
                                       class="uppercase flex-1 min-w-0 p-2 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-l bg-white dark:bg-black dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 tracking-widest font-mono transition-colors z-0">

                                <div class="flex items-center justify-center bg-gray-200 dark:bg-gray-800 border-y border-gray-300 dark:border-gray-700 px-2">
                                    <span class="text-[10px] font-bold text-gray-500">OR</span>
                                </div>

                                <button id="gpsHomeBtn" type="button" onclick="setHomeToGPS()"
                                        class="flex items-center justify-center px-3 bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold rounded-r border border-blue-600 transition-colors shadow-sm whitespace-nowrap">
                                    GPS
                                </button>
                            </div>
                        </div>
                        <div class="p-3 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-800">
                            <label for="minRunway" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">
                                Min Rwy (ft)
                            </label>
                            <input type="number" id="minRunway" placeholder="0" min="0" step="100"
                                   class="w-full p-2 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded bg-white dark:bg-black dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 font-mono transition-colors">
                        </div>
                    </div>
                </div>

                <div class="md:col-span-1 flex items-end">
                    <div class="w-full">
                        <p class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Alternate Analysis</p>
                        <button id="toggleAdvanced"
                                class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-150 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 touch-manipulation">
                            Enable Alternate Planner
                        </button>
                    </div>
                </div>
            </div>

            <div id="advancedInputs" class="hidden mt-6 pt-4 border-t border-gray-200 dark:border-gray-800">
                <h3 class="text-lg font-semibold text-blue-600 dark:text-blue-400 mb-4">Flight Plan Details</h3>
                <p class="text-sm text-gray-500 mb-3">Enter either Departure or Destination to find alternates.</p>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4">
                    <div>
                        <label for="depIcao" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Departure (ICAO)
                        </label>
                        <input type="text" id="depIcao" maxlength="4" placeholder="KSEA"
                               class="uppercase w-full p-2.5 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 font-mono transition-colors">
                    </div>
                    <div>
                        <label for="destIcao" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Destination (ICAO)
                        </label>
                        <input type="text" id="destIcao" maxlength="4" placeholder="KSAN"
                               class="uppercase w-full p-2.5 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 font-mono transition-colors">
                    </div>
                    <div>
                        <label for="searchRadius" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Search Radius (NM)
                        </label>
                        <input type="number" id="searchRadius" placeholder="220" value="220" min="1" max="999"
                               class="w-full p-2.5 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 transition-colors">
                    </div>
                    <div>
                        <label for="takeOffTime" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Takeoff (UTC)
                        </label>
                        <input type="text" id="takeOffTime" placeholder="YYYY-MM-DD HH:MM" required
                               class="w-full p-2.5 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 transition-colors cursor-pointer">
                    </div>
                    <div>
                        <label for="landingTime" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Landing (UTC)
                        </label>
                        <input type="text" id="landingTime" placeholder="YYYY-MM-DD HH:MM" required
                               class="w-full p-2.5 text-base md:text-sm border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 transition-colors cursor-pointer">
                    </div>
                </div>
            </div>

            <div class="mt-6 text-center">
                <button id="generateButton"
                        class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-12 rounded-lg shadow-lg transform transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 touch-manipulation">
                    Go!
                </button>
            </div>
        </div>

        <div id="status" class="hidden mt-6 p-4 text-center rounded-lg"></div>
        <div id="details" class="hidden mt-2 text-sm text-gray-500 text-center font-mono break-words"></div>
    </div>
    <!-- END INPUTS SECTION -->

    <!-- RESULTS CONTAINER (Full Width for Map, but constrained List) -->
    <div id="resultsContainer" class="hidden p-3 md:p-4 bg-white dark:bg-black border border-transparent dark:border-gray-800 rounded-xl shadow-inner md:max-h-[85vh] flex flex-col transition-colors duration-300 w-full h-[85vh]">

        <div class="mb-4 shrink-0 flex flex-wrap sm:flex-nowrap justify-between items-center gap-3 max-w-5xl mx-auto w-full">
            <div class="flex p-1 space-x-1 bg-gray-200 dark:bg-gray-900 rounded-xl overflow-x-auto flex-grow sm:flex-grow-0 sm:min-w-[300px] min-w-[200px] w-full sm:w-auto">
                <button id="tabMap"
                        class="tab-button flex-1 py-2.5 px-2 text-sm font-medium leading-5 rounded-lg text-center transition-all duration-200 focus:outline-none bg-blue-600 text-white shadow touch-manipulation whitespace-nowrap">
                    Map
                </button>
                <button id="tabStandard"
                        class="tab-button flex-1 py-2.5 px-2 text-sm font-medium leading-5 rounded-lg text-center transition-all duration-200 focus:outline-none text-gray-700 dark:text-gray-400 hover:bg-gray-300 dark:hover:bg-gray-800 touch-manipulation whitespace-nowrap">
                    List
                </button>
                <button id="tabRouteAnalysis"
                        class="tab-button flex-1 py-2.5 px-2 text-sm font-medium leading-5 rounded-lg text-center transition-all duration-200 focus:outline-none text-gray-700 dark:text-gray-400 hover:bg-gray-300 dark:hover:bg-gray-800 hidden touch-manipulation whitespace-nowrap">
                    Analysis
                </button>
            </div>

            <button id="downloadPdfBtn" disabled
                    class="flex-none w-auto flex items-center justify-center gap-2 bg-green-600 hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed text-white text-xs sm:text-sm font-bold py-2 px-3 sm:px-4 rounded-xl shadow-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 whitespace-nowrap">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                PDF
            </button>
        </div>

        <div class="flex-grow overflow-y-auto w-full relative">

            <!-- Map View Container (Full Width) -->
            <div id="mapView" class="hidden tab-content h-full">
                <div id="weatherMap"></div>

                <!-- Zulu Clock -->
                <div id="zuluClock">00:00:00Z</div>

                <!-- Radar Timestamp Display -->
                <div id="radarTimeDisplay">Radar Valid: --:--z</div>
                
<!-- SEARCH FOR THIS SECTION AROUND LINE 693 -->
<!-- ADS-B Credit (Obscure, Bottom Center) -->
<!-- CHANGED: bottom-0 -> bottom-6 to lift it up -->
<div id="adsbCredit" class="hidden absolute bottom-6 left-1/2 transform -translate-x-1/2 z-[1000] text-[8px] font-mono text-gray-400/60 dark:text-gray-600/60 pointer-events-none select-none pb-0.5">
    Traffic data <a href="https://airplanes.live" target="_blank" class="pointer-events-auto hover:text-gray-500 dark:hover:text-gray-400 underline decoration-dotted">airplanes.live</a>
</div>

                <!-- Unified Map Warning (Tiny Bottom Right) -->
                <div id="combinedWarning" class="hidden absolute bottom-0 right-0 z-[1100] px-1 py-0.5 bg-black/50 text-[8px] text-white/70 pointer-events-none select-none">
                    Experimental Data
                </div>

                <!-- NEW: PIREP Attribution Label (Centered Bottom) -->
                <div id="pirepAttribution" class="hidden absolute bottom-1 left-1/2 transform -translate-x-1/2 z-[1000] px-2 py-1 bg-white/75 dark:bg-black/75 backdrop-blur-sm rounded text-[9px] text-gray-700 dark:text-gray-300 pointer-events-none border border-gray-200 dark:border-gray-700 shadow-sm whitespace-nowrap">
                    PIREPS/AIREPS provided by NWS Aviation Weather Center
                </div>

                <!-- NEW: Crosshair for Selection Mode -->
                <div id="mapCrosshair" class="hidden absolute inset-0 z-[2000] pointer-events-none flex items-center justify-center">
                    <svg class="w-12 h-12 text-black dark:text-white drop-shadow-lg opacity-80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="8" />
                        <line x1="12" y1="2" x2="12" y2="22" />
                        <line x1="2" y1="12" x2="22" y2="12" />
                    </svg>
                </div>

                <!-- NEW: Selection Controls -->
                <div id="mapSelectionControls" class="hidden absolute bottom-8 left-0 right-0 z-[2000] flex justify-center gap-4 pointer-events-auto pb-safe px-4">
                    <button onclick="exitLocationSelectionMode()" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full shadow-xl transition-transform active:scale-95 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                        Cancel
                    </button>
                    <button onclick="confirmLocationSelection()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full shadow-xl transition-transform active:scale-95 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                        </svg>
                        Calculate Here
                    </button>
                </div>

                <!-- Toggle Fullscreen Button (Visible only in Embedded Mode) -->
                <button id="btnEnterFullscreen" onclick="toggleMapFullscreen()"
                        class="fullscreen-trigger p-2 bg-white dark:bg-gray-800 rounded-lg shadow-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors text-gray-700 dark:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                    </svg>
                </button>

                <!-- GPS Button (Moved to Top Right) -->
                <button id="gpsBtn" onclick="centerOnGPS()"
                        class="gps-trigger p-2 bg-white dark:bg-gray-800 rounded-lg shadow-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors text-gray-700 dark:text-gray-200 font-bold text-xs font-mono w-10 h-10 flex items-center justify-center" aria-label="Locate Me">
                    GPS
                </button>

<div class="layer-menu-container">

    <!-- 1. MAIN TOGGLE BUTTON (Put this FIRST) -->
    <button id="mainLayerToggle" onclick="toggleLayerMenu()" class="layer-btn bg-blue-600 hover:bg-blue-700 text-white z-50">
        <span class="active-indicator"></span>
        <svg id="menuIcon" class="menu-toggle-icon h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <!-- 2. EXPANDABLE ITEMS LIST (Put this SECOND) -->
    <div id="layerMenuItems" class="layer-items">
    
        <button id="runwayMapBtn" onclick="toggleRunwayOnMap()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center justify-center">
            <span class="font-black tracking-tighter leading-none">RWY</span>
        </button>

        <button id="radarToggleBtn" onclick="toggleRadar()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 16a8 8 0 11-16 0c0-4.135 3.5-7.5 8-14 4.5 6.5 8 9.865 8 14z" />
            </svg>
        </button>

        <button id="freezingBtn" onclick="toggleFreezingLayer()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 text-xl flex items-center justify-center">
            üßä
        </button>

        <button id="heatmapBtn" onclick="toggleHeatmap()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 text-lg flex items-center justify-center">
            üå°Ô∏è
        </button>

        <button id="pirepBtn" onclick="togglePireps()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 text-xl flex items-center justify-center">
            ‚úàÔ∏è
        </button>
        
        <button id="trafficBtn" onclick="toggleTraffic()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center justify-center">
            <span class="font-black leading-tight">ADS-B</span>
        </button>

        <button id="hazardsBtn" onclick="toggleHazards()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 text-lg flex items-center justify-center">
            ‚ö†Ô∏è
        </button>

        <button id="dayNightBtn" onclick="toggleDayNight()" class="layer-btn bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700 text-xl flex items-center justify-center">
            üåó
        </button>

    </div>

</div>
                  

                <!-- NEW: Heatmap Legend -->
                <div id="heatmapLegend">
                    <div id="legendTitle" class="text-xs font-bold uppercase tracking-wider text-black dark:text-white">Temperature</div>
                    <div id="legendLabels" class="legend-labels text-[10px] text-gray-600 dark:text-gray-300 mt-1">
                        <!-- Injected text -->
                    </div>
                </div>

                <!-- Floating Controls (Visible only in Fullscreen Mode) -->
                <div id="fullscreenControls" class="hidden">
                    <div class="map-overlay-top">
                        <button onclick="toggleMapFullscreen()" class="floating-pill flex items-center gap-2 px-4 py-2 text-sm font-bold text-gray-700 dark:text-gray-200 shadow-lg hover:scale-105 transition-transform cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                            Back to Report
                        </button>
                    </div>
                    <!-- Legend Pill Removed -->
                </div>
            </div>

            <!-- List View (Constrained to max-w-5xl so it's readable) -->
            <div id="weatherList" class="hidden tab-content w-full max-w-5xl mx-auto"></div>

            <!-- Analysis View (Constrained) -->
            <div id="routeAnalysisView" class="hidden tab-content p-2 md:p-4 w-full max-w-5xl mx-auto"></div>
<!-- Custom Dashboard View -->
<div id="customDashboardView" class="hidden tab-content w-full">
    <!-- Sticky Dashboard Controls -->
    <div class="sticky top-0 z-[500] bg-gray-100/95 dark:bg-gray-900/95 backdrop-blur-md border-b border-gray-200 dark:border-gray-800 shadow-md transition-all duration-300">
        <div class="max-w-7xl mx-auto flex flex-col gap-3 p-3">
            
            <div class="flex items-center justify-between gap-3">
                <!-- Close Button -->
                <button onclick="exitDashboard()" class="p-2 bg-gray-200 dark:bg-gray-800 rounded-lg text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-700 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/></svg>
                </button>

                <!-- Input Field Group -->
                <div class="flex-1 flex gap-2">
                    <div class="flex-1 flex shadow-sm">
                        <!-- Updated Placeholder -->
                        <input type="text" id="dashInput" placeholder="e.g. KJFK" maxlength="4" 
                               class="uppercase w-full p-2 border border-gray-300 dark:border-gray-700 rounded-l-xl bg-white dark:bg-black dark:text-white font-mono focus:ring-2 focus:ring-indigo-500 outline-none text-sm min-w-[60px]">
                        <button onclick="addDashboardStation()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 sm:px-4 rounded-r-xl font-bold text-xs shadow-sm">
                            ADD
                        </button>
                    </div>
                    
                    <!-- Advanced Search Button (Updated Label) -->
                    <button onclick="openDashSearchModal()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 rounded-xl font-bold text-xs shadow-sm whitespace-nowrap flex items-center gap-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
                        <span class="hidden sm:inline">Advanced</span>
                    </button>
                </div>

                <!-- Clear All Button -->
                <button onclick="clearDashboard()" class="p-2 bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 rounded-lg hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors" title="Clear All Tiles">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                </button>
            </div>

            <!-- Floating Time Slider -->
            <div class="w-full bg-white/50 dark:bg-black/50 p-2 rounded-xl border border-gray-200 dark:border-gray-800">
                <div class="flex justify-between items-center mb-1 px-1">
                    <div class="flex items-baseline gap-2">
                        <span id="dashTimeLabel" class="text-lg font-black text-indigo-600 dark:text-indigo-400 font-mono">Current</span>
                        <span id="dashRelativeLabel" class="text-[10px] font-bold text-gray-500 font-mono bg-gray-200 dark:bg-gray-800 px-1.5 rounded">+0h</span>
                    </div>
                    <span class="text-[9px] font-bold text-gray-400 uppercase">Forecast Horizon</span>
                </div>
                <input type="range" id="dashTimeSlider" min="0" max="30" value="0" step="1" 
                       class="w-full h-2 bg-gray-300 rounded-full appearance-none cursor-pointer dark:bg-gray-700 accent-indigo-600"
                       oninput="updateDashboardTime(this.value)">
            </div>
        </div>
    </div>

    <!-- Scrollable Tile Grid -->
    <div class="p-4">
        <div id="dashboardGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-3 w-full"></div>
    </div>
</div>
<!-- Custom Clear Confirmation Modal -->
<div id="confirmClearModal" class="hidden fixed inset-0 z-[2100] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4" onclick="closeClearModal()">
    <div class="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-sm p-6 border border-gray-200 dark:border-gray-800 text-center transform transition-all scale-100" onclick="event.stopPropagation()">
        <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900/30 mb-4">
            <svg class="h-6 w-6 text-red-600 dark:text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
        </div>
        <h3 class="text-xl font-bold text-gray-900 dark:text-white mb-2">Clear Dashboard?</h3>
        <p class="text-sm text-gray-500 dark:text-gray-400 mb-6">This will remove all <b>${dashboardState.stations.length}</b> tiles. This action cannot be undone.</p>
        <div class="flex gap-3 justify-center">
            <button onclick="closeClearModal()" class="flex-1 px-4 py-2 bg-gray-200 dark:bg-gray-800 hover:bg-gray-300 dark:hover:bg-gray-700 rounded-lg font-bold text-gray-700 dark:text-gray-300 transition-colors">
                Cancel
            </button>
            <button onclick="confirmClearAction()" class="flex-1 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg font-bold shadow-lg transition-colors">
                Yes, Clear All
            </button>
        </div>
    </div>
</div>
<!-- Advanced Search Modal (Added) -->
<div id="dashboardSearchModal" class="hidden fixed inset-0 z-[2000] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4" onclick="closeDashSearchModal()">
    <div class="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-md p-6 border border-gray-200 dark:border-gray-800" onclick="event.stopPropagation()">
        <h3 class="text-xl font-bold text-gray-900 dark:text-white mb-4">Bulk Add Stations</h3>
        
        <div class="space-y-4">
            <div>
                <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Center Airport (ICAO)</label>
                <input type="text" id="advSearchCenter" placeholder="KDFW" maxlength="4" class="uppercase w-full p-3 bg-gray-100 dark:bg-black border border-gray-300 dark:border-gray-700 rounded-lg font-mono text-lg focus:ring-2 focus:ring-blue-500 outline-none">
            </div>

            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Radius (NM)</label>
                    <input type="number" id="advSearchRadius" value="50" min="1" max="300" class="w-full p-3 bg-gray-100 dark:bg-black border border-gray-300 dark:border-gray-700 rounded-lg font-mono outline-none">
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Min Rwy (ft)</label>
                    <input type="number" id="advSearchRwy" value="0" step="500" class="w-full p-3 bg-gray-100 dark:bg-black border border-gray-300 dark:border-gray-700 rounded-lg font-mono outline-none">
                </div>
            </div>
            
            <div id="advSearchStatus" class="text-xs text-center min-h-[1.5em] font-bold text-blue-500"></div>

            <div class="flex gap-3 mt-6">
                <button onclick="closeDashSearchModal()" class="flex-1 py-3 bg-gray-200 dark:bg-gray-800 hover:bg-gray-300 dark:hover:bg-gray-700 rounded-xl font-bold transition-colors">Cancel</button>
                <button onclick="performAdvancedDashSearch()" class="flex-1 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-bold shadow-lg transition-transform active:scale-95">Find & Add</button>
            </div>
        </div>
    </div>
</div>

<script>
    // --- APP CONFIG ---
    const CURRENT_VERSION = 'v20000.5.3'; // Incremented Version
    const GITHUB_REPO = 'Unpiloted0852/AvWx';

    // Global Data Storage for Modal Access
    let g_analysisData = {
        dep: { results: [], start: null, end: null },
        dest: { results: [], start: null, end: null }
    };

    // Store current report data for PDF generation and Refresh
    let currentReportData = {
        stationsData: [],
        refName: null,
        routeAnalysisResult: null
    };

    // Global User GPS Storage for Sorting
    let gpsReferenceCoords = null;

    // Auto-Refresh Timer ID
    let refreshIntervalId = null;

    // Map Globals
    // Add with other globals

let hazardRenderer = null;
let trafficLayer = null; 
let selectedPlaneTrace = null; // Stores the active flight path polyline
let selectedPlaneTraceEst = null; 
let trafficRefreshInterval = null;
let selectedAircraftHex = null;
let trafficMarkers = new Map(); // Stores markers to allow smooth movement updates
    let mapInstance = null;
    let markerLayerGroup = null;
    let labelLayerGroup = null; // Optimized layer for text
    let freezingLayer = null; // New Freezing Level Layer
    let pirepLayer = null; // NEW PIREP Layer
    let hazardsLayer = null; // NEW Hazards/Sigmet Layer
    let dayNightLayer = null; // NEW Day/Night Layer
    let dayNightInterval = null;
    let mapRenderer = null;
    // We create separate renderers for the route pane and marker pane to solve click issues
    let routeRenderer = null;
    let markerRenderer = null;

    // TWO Data Sets:
    // 1. currentStationsData: Filtered by runway (for display/list)
    // 2. allStationsData: Unfiltered (for math/interpolation)
    let currentStationsData = [];
    let allStationsData = [];

    let radarLayer = null; // Radar Layer Global
    let radarRefreshInterval = null; // Store interval ID for radar

// Global Hazards Interval
let hazardsRefreshInterval = null;

    // GPS Marker Global
    let userLocationMarker = null;

    // Lazy Loading Globals
    let listRenderIndex = 0;
    const LIST_BATCH_SIZE = 20; // Reduced to ensure scrollbar trigger and performance

    // Wake Lock Global
    let wakeLock = null;

    // --- LAYER MENU LOGIC ---
    let isLayerMenuOpen = false;

    function toggleLayerMenu() {
        const menu = document.getElementById('layerMenuItems');
        const icon = document.getElementById('menuIcon');
        const container = document.querySelector('.layer-menu-container');

        isLayerMenuOpen = !isLayerMenuOpen;

        if (isLayerMenuOpen) {
            container.classList.add('layer-menu-open');
            // Change icon to X
            icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />';
        } else {
            container.classList.remove('layer-menu-open');
            // Change icon back to Stack/Map
            icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />';
        }
    }


function updateLayerActiveState() {
    const hasRadar = !!radarLayer;
    const hasFreezing = !!freezingLayer;
    const hasHeatmap = (heatmapMode !== 0);
    const hasPirep = !!pirepLayer;
    const hasHazards = !!hazardsLayer;
    const hasDayNight = !!dayNightLayer;
    const hasRunways = showRunwaysOnMap; 
    const hasTraffic = !!trafficLayer; 

    const mainBtn = document.getElementById('mainLayerToggle');
    
    if (hasRadar || hasFreezing || hasHeatmap || hasPirep || hasHazards || hasDayNight || hasRunways || hasTraffic) {
        mainBtn.classList.add('has-active-layers');
    } else {
        mainBtn.classList.remove('has-active-layers');
    }
    updateMapWarnings();
    
    // NEW: Save settings every time a layer changes
    saveLayerSettings();
}

    // --- LIBRARIES SAFE LOADING ---
    let jsPDF = null;
    try {
        if (window.jspdf && window.jspdf.jsPDF) {
             jsPDF = window.jspdf.jsPDF;
        } else if (window.jspdf) {
             jsPDF = window.jspdf;
        }
    } catch(e) {
        console.warn("PDF Library not loaded correctly");
    }

    const generateButton = document.getElementById('generateButton');
    const downloadPdfBtn = document.getElementById('downloadPdfBtn');
    const icaoInput = document.getElementById('icaoInput');
    const statusEl = document.getElementById('status');
    const detailsEl = document.getElementById('details');
    const resultsContainerEl = document.getElementById('resultsContainer');
    const weatherListEl = document.getElementById('weatherList');
    const routeAnalysisViewEl = document.getElementById('routeAnalysisView');
    const toggleAdvancedButton = document.getElementById('toggleAdvanced');
    const advancedInputsEl = document.getElementById('advancedInputs');
    const tabStandard = document.getElementById('tabStandard');
    const tabMap = document.getElementById('tabMap');
    const tabRouteAnalysis = document.getElementById('tabRouteAnalysis');
    const nodataLegendEl = document.getElementById('nodata-legend');

    const depIcaoInput = document.getElementById('depIcao');
    const destIcaoInput = document.getElementById('destIcao');
    const takeOffTimeInput = document.getElementById('takeOffTime');
    const landingTimeInput = document.getElementById('landingTime');
    const searchRadiusInput = document.getElementById('searchRadius');
    const minRunwayInput = document.getElementById('minRunway');
    const modal = document.getElementById('tileModal');
    const interpolationModal = document.getElementById('interpolationModal');
    const zuluClockEl = document.getElementById('zuluClock');
    const unitToggleBtn = document.getElementById('unitToggleBtn');
    const pressureUnitToggleBtn = document.getElementById('pressureUnitToggleBtn'); // NEW
    const radarToggleBtn = document.getElementById('radarToggleBtn');
    const radarTimeDisplay = document.getElementById('radarTimeDisplay');

    // Attach scroll listener for Lazy Loading
    const scrollContainer = resultsContainerEl.querySelector('.flex-grow');
    if (scrollContainer) {
        scrollContainer.addEventListener('scroll', () => {
            if (!weatherListEl.classList.contains('hidden')) {
                const { scrollTop, scrollHeight, clientHeight } = scrollContainer;
                if (scrollTop + clientHeight >= scrollHeight - 300) {
                    renderNextBatch();
                }
            }
        });
    }
    
document.getElementById('dashInput').addEventListener("keydown", function(event) {
    if (event.key === "Enter") {
        event.preventDefault();
        addDashboardStation();
    }
});

    // --- ENTER KEY LISTENER ---
    icaoInput.addEventListener("keydown", function(event) {
        if (event.key === "Enter") {
            event.preventDefault(); // Prevent default form submission if applicable
            handleGenerateClick(event, false);
        }
    });

    // Unit State
    let useCelsius = false;
    let useHpa = false; // Default to inHg (false)

    try {
        useCelsius = localStorage.getItem('useCelsius') === 'true';
        useHpa = localStorage.getItem('useHpa') === 'true'; // Load pressure pref
    } catch(e) {}

    // Helper to get display temperature
    function getDisplayTemp(metarObj) {
        if (!metarObj) return "N/A";
        return useCelsius ? metarObj.tempC : metarObj.tempF;
    }

    function updateUnitButtons() {
        unitToggleBtn.textContent = useCelsius ? '¬∞C' : '¬∞F';
        pressureUnitToggleBtn.textContent = useHpa ? 'hPa' : 'inHg';
    }
    // Initialize button text on load
    updateUnitButtons();

    function toggleUnits() {
        useCelsius = !useCelsius;
        try { localStorage.setItem('useCelsius', useCelsius); } catch(e){}
        updateUnitButtons();
        // Refresh Heatmap if Temp mode is active
        if (heatmapMode === 1 && heatmapLayer) {
            // Re-create the layer to force re-draw with new units
            mapInstance.removeLayer(heatmapLayer);
            heatmapLayer = new L.WeatherIsoLayer({ mode: 'temp' });
            mapInstance.addLayer(heatmapLayer);

            // Refresh Legend Title
            const legendTitle = document.getElementById('legendTitle');
            if (legendTitle) legendTitle.textContent = `Temp Lines (${useCelsius ? '¬∞C' : '¬∞F'})`;
        }
        // Re-render UI if data exists
        if (currentReportData && currentReportData.stationsData.length > 0) {
            refreshDataSilent(true); // Skip fetch, just redraw
        }
    }

    function togglePressureUnits() {
        useHpa = !useHpa;
        try { localStorage.setItem('useHpa', useHpa); } catch(e){}
        updateUnitButtons();
         // Refresh Heatmap if Pressure mode is active
         if (heatmapMode === 2 && heatmapLayer) {
            // Re-create layer to force re-draw
            mapInstance.removeLayer(heatmapLayer);
            heatmapLayer = new L.WeatherIsoLayer({ mode: 'pressure' });
            mapInstance.addLayer(heatmapLayer);

            // Refresh Legend Title
            const legendTitle = document.getElementById('legendTitle');
            if (legendTitle) legendTitle.textContent = `Pressure Lines (${useHpa ? 'hPa' : 'inHg'})`;
        }
        // Re-render UI if data exists (affects Records modal mainly)
        if (currentReportData && currentReportData.stationsData.length > 0) {
             // If records modal is open, refresh it?
             if (!recordsModal.classList.contains('hidden')) {
                 showRecords();
             }
        }
    }
    


    // URLs - Pointing to GitHub Pages (The correct way to serve app data)
    // -----------------------------------------------------------------------
    // REPLACE 'Unpiloted0852' and 'AvWx-Web' if you change your username/repo
    const GH_USER = 'Unpiloted0852';
    const GH_REPO = 'AvWx-Web';
    
    const BASE_URL = `https://${GH_USER}.github.io/${GH_REPO}`;

    const TAF_DATA_URL = `${BASE_URL}/data/tafs.cache.xml.gz`;
    const METAR_DATA_URL = `${BASE_URL}/data/metars.cache.xml.gz`;
    const STATIONS_DATA_URL = `${BASE_URL}/data/stations.cache.xml.gz`;
    const PIREP_DATA_URL = `${BASE_URL}/data/aircraftreports.cache.xml.gz`;
    const RUNWAY_DATA_URL = `${BASE_URL}/data/runways.csv`;
    
    // UPDATED: Point to local JSON files
    const SIGMET_DOMESTIC_URL = `${BASE_URL}/data/sigmet_domestic.json`;
    const SIGMET_INTL_URL = `${BASE_URL}/data/sigmet_intl.json`;
    
    // We strictly use local fetches now, so Proxy is mostly unused but keep defined
    const PROXY_URL = 'https://corsproxy.io/?';

    const MAX_RETRIES = 3;
    const PAGE_MARGIN = 15;
    const PAGE_WIDTH = 210;
    const PAGE_HEIGHT = 297;
    const USABLE_WIDTH = PAGE_WIDTH - (PAGE_MARGIN * 2);
    const LINE_SPACING = 4;
    const MAX_ROUTE_DISTANCE_NM = 220;

    // Cache
    let cachedStationMap = null;
    let cachedRunwayMap = null;
    let routeAnalysisEnabled = false;

    const CATEGORY_ORDER = { 'LIFR': 4, 'IFR': 3, 'MVFR': 2, 'VFR': 1, 'NODATA': 0 };
    // UPDATED COLORS (MVFR IS NOW LIGHTER #2563eb = [37, 99, 235])
    const COLORS = {
        VFR: [0, 170, 0],
        MVFR: [37, 99, 235], // Updated
        IFR: [200, 0, 0],
        LIFR: [255, 20, 147],
        NODATA: [150, 150, 150]
    };

// --- WEATHER MATH HELPERS ---

function calculateWindChill(tempF, windMph) {
    // NWS Formula: 35.74 + 0.6215T - 35.75(V^0.16) + 0.4275T(V^0.16)
    return 35.74 + (0.6215 * tempF) - (35.75 * Math.pow(windMph, 0.16)) + (0.4275 * tempF * Math.pow(windMph, 0.16));
}

function calculateHeatIndex(tempF, rh) {
    // NWS Rothfusz Regression
    let hi = -42.379 + 2.04901523 * tempF + 10.14333127 * rh - 0.22475541 * tempF * rh - 0.00683783 * tempF * tempF - 0.05481717 * rh * rh + 0.00122874 * tempF * tempF * rh + 0.00085282 * tempF * rh * rh - 0.00000199 * tempF * tempF * rh * rh;

    // Adjustments
    if (rh < 13 && tempF > 80 && tempF < 112) {
        hi -= ((13 - rh) / 4) * Math.sqrt((17 - Math.abs(tempF - 95)) / 17);
    } else if (rh > 85 && tempF > 80 && tempF < 87) {
        hi += ((rh - 85) / 10) * ((87 - tempF) / 5);
    }
    return hi;
}

// Logic Coordinator
function calculateFeelsLike(tempC, windKt, rh) {
    if (tempC === null || isNaN(tempC)) return null;

    const tempF = (tempC * 1.8) + 32;
    const windMph = (windKt || 0) * 1.15078;
    
    let finalF = tempF;
    let label = null; // Default to null (don't show if just normal temp)

    // 1. Wind Chill: Temp < 50F and Wind > 3 MPH
    if (tempF < 50 && windMph > 3) {
        finalF = calculateWindChill(tempF, windMph);
        label = "Wind Chill";
    } 
    // 2. Heat Index: Temp > 80F (requires RH)
    else if (tempF > 80 && rh !== null && !isNaN(rh)) {
        finalF = calculateHeatIndex(tempF, rh);
        // Only label it Heat Index if it actually feels hotter
        if (finalF > tempF) label = "Heat Index";
    }

    // If neither condition met, we return the Current Temp (finalF = tempF)
    // But we leave label as null so we don't clutter the UI with "Feels Like: [Same Number]"

    if (!label) return null; // Logic: If it matches current temp, don't display extra tag

    return {
        f: Math.round(finalF),
        c: Math.round((finalF - 32) * (5/9)),
        label: label
    };
}

    // --- MATH HELPERS INCLUDING DENSITY ALTITUDE ---
    function calculateDensityAltitude(elevationFt, tempC, altimInHg) {
        if (elevationFt === null || tempC === null || altimInHg === null || isNaN(elevationFt) || isNaN(tempC) || isNaN(altimInHg)) {
            return null;
        }

        // 1. Calculate Standard Temperature (ISA) at this elevation (drops 2¬∞C per 1000ft)
        const isaTemp = 15 - (2 * (elevationFt / 1000));

        // 2. Calculate Pressure Altitude
        // Standard lapse rate: (29.92 - Altimeter) * 1000 + Elevation
        const pressureAlt = (29.92 - altimInHg) * 1000 + elevationFt;

        // 3. Calculate Density Altitude
        // DA = PA + [120 * (OAT - ISA)]
        const da = Math.round(pressureAlt + (120 * (tempC - isaTemp)));

        return `DA ${da.toLocaleString()}ft`;
    }

    // --- PDF HELPERS DEFINED AT GLOBAL SCOPE ---
    function drawStyledText(doc, lineText, x, y, baseColor) {
        const words = lineText.split(' ');
        let currentX = x;
        doc.setTextColor(...baseColor);
        doc.setFont("courier", "normal");
        doc.setFontSize(9);
        const spaceWidth = doc.getTextWidth(" ");
        for (let word of words) {
            const shouldBold = isPrecipOrTS(word);
            doc.setFont("courier", shouldBold ? "bold" : "normal");
            doc.text(word, currentX, y);
            currentX += doc.getTextWidth(word) + spaceWidth;
        }
    }

    function drawPdfLegend(doc, cursorY) {
        doc.setFont("helvetica", "bold");
        doc.setFontSize(10);
        doc.text("METAR Flight Categories", PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 6;
        const legendItems = [
            { label: "VFR", color: COLORS.VFR },
            { label: "MVFR", color: COLORS.MVFR },
            { label: "IFR", color: COLORS.IFR },
            { label: "LIFR", color: COLORS.LIFR },
            { label: "NODATA", color: COLORS.NODATA }
        ];
        const itemWidth = 30;
        const totalLegendWidth = legendItems.length * itemWidth;
        const startX = (PAGE_WIDTH - totalLegendWidth) / 2;
        const boxSize = 4;
        const padding = 4;
        for (let i = 0; i < legendItems.length; i++) {
            const x = startX + i * itemWidth;
            const item = legendItems[i];
            doc.setFillColor(...item.color);
            doc.rect(x, cursorY - 3, boxSize, boxSize, 'F');
            doc.setFont("helvetica", "normal");
            doc.setFontSize(8);
            doc.setTextColor(30, 30, 30);
            doc.text(item.label, x + boxSize + padding, cursorY);
        }
        return cursorY + 6;
    }
    
    function formatObsTime(isoString) {
    if (!isoString) return "----Z";
    const date = new Date(isoString);
    const h = String(date.getUTCHours()).padStart(2, '0');
    const m = String(date.getUTCMinutes()).padStart(2, '0');
    return `${h}${m}Z`;
}

    function drawRouteAnalysisPDFPage(doc, analysisResult) {
        const { depResults, destResults, takeoffStart, takeoffEnd, landingStart, landingEnd, depName, destName, depFullName, destFullName } = analysisResult;
        let cursorY = PAGE_MARGIN;
        const tStart = takeoffStart ? formatTimeHHMM(takeoffStart) : 'N/A';
        const tEnd = takeoffEnd ? formatTimeHHMM(takeoffEnd) : 'N/A';
        const lStart = landingStart ? formatTimeHHMM(landingStart) : 'N/A';
        const lEnd = landingEnd ? formatTimeHHMM(landingEnd) : 'N/A';

        doc.setFont("helvetica", "bold");
        doc.setFontSize(18);
        doc.setTextColor(30, 30, 30);
        doc.text("Alternate Weather Analysis", PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 10;
        doc.setFontSize(12);
        doc.setTextColor(50, 50, 50);

        let headerText = "Flight Plan";
        if (depName !== 'N/A' && destName !== 'N/A') headerText = `Flight: ${depName} to ${destName}`;
        else if (depName !== 'N/A') headerText = `Departure: ${depName}`;
        else if (destName !== 'N/A') headerText = `Destination: ${destName}`;

        doc.text(headerText, PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 10;

        const drawGridSection = (title, windowStr, items) => {
             if (cursorY + 20 > PAGE_HEIGHT - PAGE_MARGIN) { doc.addPage(); cursorY = PAGE_MARGIN; }
             doc.setFont("helvetica", "bold");
             doc.setFontSize(14);
             doc.setTextColor(30, 30, 30);
             doc.text(title, PAGE_MARGIN, cursorY);
             doc.setFont("courier", "normal");
             doc.setFontSize(10);
             doc.setTextColor(80, 80, 80);
             doc.text(windowStr, PAGE_WIDTH - PAGE_MARGIN, cursorY, { align: "right" });
             cursorY += 8;
             doc.setLineWidth(0.2);
             doc.setDrawColor(200, 200, 200);

             let startTileX = PAGE_MARGIN;
             const tileWidth = 30;
             const tileHeight = 20; // Increased height for extra text
             const tileMargin = 5;
             const maxTilesPerRow = Math.floor(USABLE_WIDTH / (tileWidth + tileMargin));
             let col = 0; let row = 0;

             if (!items || items.length === 0) {
                 doc.setFont("helvetica", "italic");
                 doc.setFontSize(10);
                 doc.text("No alternates found within range.", PAGE_MARGIN, cursorY);
                 cursorY += 15;
                 return;
             }

             for (const data of items) {
                const color = getCategoryColor(data.worstCategory);
                doc.setFillColor(...color);
                let x = startTileX + col * (tileWidth + tileMargin);
                let y = cursorY + row * (tileHeight + tileMargin);
                if (y + tileHeight > PAGE_HEIGHT - PAGE_MARGIN) {
                    doc.addPage();
                    cursorY = PAGE_MARGIN;
                    row = 0; col = 0;
                    doc.setLineWidth(0.2);
                    doc.setDrawColor(200, 200, 200);
                    doc.setFillColor(...color);
                    x = startTileX + col * (tileWidth + tileMargin);
                    y = cursorY + row * (tileHeight + tileMargin);
                }
                doc.rect(x, y, tileWidth, tileHeight, 'FD');
                const avgColor = (color[0] + color[1] + color[2]) / 3;
                doc.setTextColor(avgColor > 128 ? 0 : 255, avgColor > 128 ? 0 : 255, avgColor > 128 ? 0 : 255);

                doc.setFont("helvetica", "bold");
                doc.setFontSize(9);
                doc.text(data.id, x + tileWidth / 2, y + 4, { align: 'center' });

                doc.setFont("helvetica", "normal");
                doc.setFontSize(5);
                let displayName = data.name || '';
                if (displayName.length > 20) displayName = displayName.substring(0, 18) + '..';
                doc.text(displayName, x + tileWidth / 2, y + 8, { align: 'center' });

                doc.setFont("helvetica", "bold");
                doc.setFontSize(6);
                doc.text(`${data.worstCategory}`, x + tileWidth / 2, y + 12, { align: 'center' });

                // Draw condition text if it exists (worse than VFR)
                if (data.conditionText) {
                    doc.setFont("courier", "normal");
                    doc.setFontSize(5);
                    const condSplit = doc.splitTextToSize(data.conditionText, tileWidth - 2);
                    doc.text(condSplit, x + tileWidth / 2, y + 15, { align: 'center' });
                }

                doc.setFont("helvetica", "normal");
                doc.setFontSize(5);
                // Move distance to bottom
                doc.text(`${data.distance.toFixed(0)} NM`, x + tileWidth / 2, y + tileHeight - 2, { align: 'center' });

                col++;
                if (col >= maxTilesPerRow) { col = 0; row++; }
             }
             cursorY += (row + 1) * (tileHeight + tileMargin) + 5;
        };

        if (takeoffStart && depName !== 'N/A') {
            drawGridSection("Departure Alternates", `Window: ${tStart} - ${tEnd}`, depResults);
        }
        if (landingStart && destName !== 'N/A') {
            drawGridSection("Destination Alternates", `Window: ${lStart} - ${lEnd}`, destResults);
        }

        return cursorY;
    }

    // --- INITIALIZATION ---

    // Zulu Clock Update
    let timeOffset = 0;

async function syncTime() {
    try {
        const start = Date.now(); // Mark when we started the request
        
        // Use WorldTimeAPI (or similar) which gives milliseconds
        const res = await fetch("https://worldtimeapi.org/api/timezone/Etc/UTC");
        const data = await res.json();
        
        const end = Date.now(); // Mark when we received the response
        
        // Calculate network round-trip time (RTT)
        const duration = end - start;
        
        // The server time was generated roughly halfway through the request
        // (This is a standard NTP estimation)
        const serverTime = new Date(data.utc_datetime).getTime();
        
        // Adjust: ServerTime + (Half of the trip time) - Now
        timeOffset = (serverTime + (duration / 2)) - end;

        console.log(`Time synced. Offset: ${timeOffset}ms (Latency: ${duration}ms)`);
        
    } catch (e) {
        console.warn("Time sync failed, falling back to system clock:", e);
        timeOffset = 0;
    }
}

    function updateZuluClock() {
        const now = new Date(Date.now() + timeOffset);
        const hours = String(now.getUTCHours()).padStart(2, '0');
        const minutes = String(now.getUTCMinutes()).padStart(2, '0');
        const seconds = String(now.getUTCSeconds()).padStart(2, '0');
        zuluClockEl.textContent = `${hours}:${minutes}:${seconds}Z`;
    }

    // Sync time on load
    syncTime();
    // Update every second
    setInterval(updateZuluClock, 1000);
    updateZuluClock();

    function formatUtcForInput(date) {
        const Y = date.getUTCFullYear();
        const M = String(date.getUTCMonth() + 1).padStart(2, '0');
        const D = String(date.getUTCDate()).padStart(2, '0');
        const h = String(date.getUTCHours()).padStart(2, '0');
        const m = String(date.getUTCMinutes()).padStart(2, '0');
        return `${Y}-${M}-${D} ${h}:${m}`;
    }

    function parseUtcString(str) {
        if (!str) return null;
        return new Date(str.replace(' ', 'T') + 'Z');
    }

    function initializeTimeInputs() {
        const now = new Date();
        let takeoffTime = new Date(now.getTime() + 60 * 60 * 1000);
        if (takeoffTime.getUTCMinutes() > 0) {
            takeoffTime.setUTCHours(takeoffTime.getUTCHours() + 1);
            takeoffTime.setUTCMinutes(0);
        }
        takeoffTime.setUTCSeconds(0);
        takeoffTime.setUTCMilliseconds(0);
        const landingTime = new Date(takeoffTime.getTime() + 7 * 60 * 60 * 1000);

        const commonConfig = {
            enableTime: true,
            dateFormat: "Y-m-d H:i",
            time_24hr: true,
            disableMobile: true,
            minuteIncrement: 1,
            static: true
        };
        flatpickr("#takeOffTime", { ...commonConfig, defaultDate: formatUtcForInput(takeoffTime) });
        flatpickr("#landingTime", { ...commonConfig, defaultDate: formatUtcForInput(landingTime) });
    }
    initializeTimeInputs();

    function formatTimeHHMM(date) {
        const h = String(date.getUTCHours()).padStart(2, '0');
        const m = String(date.getUTCMinutes()).padStart(2, '0');
        return `${h}:${m}Z`;
    }

    function formatRemainingTime(targetDate) {
        if (!targetDate) return "";
        const now = new Date();
        const diffMs = targetDate.getTime() - now.getTime();

        if (diffMs < 0) return "Expired";

        const hours = Math.floor(diffMs / (1000 * 60 * 60));
        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

        return `Expires: ${hours}h ${minutes}m`;
    }

    // Auto-center map helper
    function centerMapOnHome() {
        if (!mapInstance || !cachedStationMap) return;
        const homeInput = document.getElementById('icaoInput').value.trim().toUpperCase();
        if (homeInput.length >= 3) {
             const homeCoords = getCoordsForICAO(homeInput, cachedStationMap);
             if (homeCoords && homeCoords.lat !== null) {
                 mapInstance.setView([homeCoords.lat, homeCoords.lon], 7);
             }
        }
    }

    // --- ISO-LINE HEATMAP CONFIGURATION ---
    let heatmapLayer = null;
    let heatmapMode = 0; // 0: Off, 1: Temp, 2: Pressure

   // --- ISO-LINE HEATMAP CONFIGURATION (SMOOTHED) ---
    if (typeof L.WeatherIsoLayer === 'undefined') {
        L.WeatherIsoLayer = L.Layer.extend({
            initialize: function(options) {
                this.mode = options.mode || 'temp'; 
            },

            onAdd: function(map) {
                this._map = map;
                this._canvas = L.DomUtil.create('canvas', 'leaflet-weather-iso-layer');
                this._canvas.style.pointerEvents = 'none';
                this._canvas.style.zIndex = 200; 
                map.getPanes().overlayPane.appendChild(this._canvas);

                map.on('moveend', this._update, this);
                map.on('zoomend', this._update, this);
                this._update();
            },

            onRemove: function(map) {
                map.getPanes().overlayPane.removeChild(this._canvas);
                map.off('moveend', this._update, this);
                map.off('zoomend', this._update, this);
            },

            _update: function() {
                if (!this._map) return;
                const map = this._map;
                const size = map.getSize();
                const canvas = this._canvas;

                const dpr = window.devicePixelRatio || 1;
                canvas.width = size.x * dpr;
                canvas.height = size.y * dpr;
                canvas.style.width = size.x + 'px';
                canvas.style.height = size.y + 'px';

                const bounds = map.getBounds();
                const topLeft = map.latLngToLayerPoint(bounds.getNorthWest());
                L.DomUtil.setPosition(canvas, topLeft);

                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr); 

                this._draw(ctx);
            },

            _draw: function(ctx) {
                const width = this._canvas.width / (window.devicePixelRatio || 1);
                const height = this._canvas.height / (window.devicePixelRatio || 1);
                const map = this._map;

                ctx.clearRect(0, 0, width, height);

                if (!allStationsData || allStationsData.length === 0) return;

                // 1. Filter stations
                const bounds = map.getBounds();
                const pad = 5.0; 
                const south = bounds.getSouth() - pad;
                const north = bounds.getNorth() + pad;
                // Note: Longitude filtering is removed/simplified because we want to include stations 
                // that might wrap around the world if we are looking at the edge.
                
                const relevantStations = allStationsData.filter(s => {
                    if(s.latitude === null || s.longitude === null || !s.metar) return false;
                    let val;
                    if(this.mode === 'temp') val = s.metar.rawTempC;
                    else val = s.metar.altimInHg;
                    if (val === null || isNaN(val)) return false;
                    
                    // Simple latitude check is enough, longitude check is skipped to handle wrapping better
                    return s.latitude >= south && s.latitude <= north;
                });

                if (relevantStations.length < 5) return;

                const stations = relevantStations.map(s => ({
                    lat: s.latitude,
                    lon: s.longitude,
                    val: this.mode === 'temp' ? s.metar.rawTempC : s.metar.altimInHg
                }));

                // 2. High Resolution Grid
                const RES = 8; 
                const cols = Math.ceil(width / RES);
                const rows = Math.ceil(height / RES);
                const NEIGHBOR_COUNT = 5;
                const grid = [];

                for (let y = 0; y <= rows; y++) {
                    grid[y] = [];
                    for (let x = 0; x <= cols; x++) {
                        const px = x * RES;
                        const py = y * RES;
                        const ll = map.containerPointToLatLng(L.point(px, py));
                        
                        let closest = [];
                        for (let i = 0; i < stations.length; i++) {
                            const s = stations[i];
                            const dLat = s.lat - ll.lat;
                            
                            // UPDATED: Longitude distance with wrapping
                            let dLon = Math.abs(s.lon - ll.lng);
                            if (dLon > 180) dLon = 360 - dLon;
                            
                            const distSq = dLat*dLat + dLon*dLon;

                            if (closest.length < NEIGHBOR_COUNT) {
                                closest.push({ distSq: distSq, val: s.val });
                                closest.sort((a,b) => a.distSq - b.distSq);
                            } else if (distSq < closest[NEIGHBOR_COUNT-1].distSq) {
                                closest[NEIGHBOR_COUNT-1] = { distSq: distSq, val: s.val };
                                closest.sort((a,b) => a.distSq - b.distSq);
                            }
                        }

                        if (closest[0].distSq > 5.0) { 
                            grid[y][x] = null;
                            continue;
                        }

                        let sumWeights = 0;
                        let weightedVal = 0;
                        for(let i=0; i<closest.length; i++) {
                            const w = 1 / (closest[i].distSq + 0.000001);
                            weightedVal += closest[i].val * w;
                            sumWeights += w;
                        }
                        grid[y][x] = (sumWeights > 0) ? weightedVal / sumWeights : null;
                    }
                }

                // 3. Define Thresholds & 4. Marching Squares (Same as before)
                let steps = [];
                if (this.mode === 'temp') {
                    for(let t = -40; t <= 50; t += 5) steps.push(t);
                } else {
                    for(let p = 28.00; p <= 31.00; p += 0.10) steps.push(parseFloat(p.toFixed(2)));
                }

                ctx.lineWidth = 2; 
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const getIsoColor = (val, type) => {
                    if (type === 'temp') {
                        if (val <= 0) return 'rgba(148,0,211,0.8)';
                        if (val <= 15) return 'rgba(0,0,255,0.8)';
                        if (val <= 25) return 'rgba(0,200,0,0.8)';
                        if (val <= 30) return 'rgba(255,165,0,0.8)';
                        return 'rgba(255,0,0,0.8)';
                    } else {
                        if (val < 29.92) return 'rgba(0,0,255,0.8)';
                        return 'rgba(255,0,0,0.8)';
                    }
                };

                const lerp = (val, v0, v1, p0, p1) => {
                    const ratio = (val - v0) / (v1 - v0);
                    return p0 + ratio * (p1 - p0);
                };

                const labels = [];

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const vTL = grid[y][x];
                        const vTR = grid[y][x+1];
                        const vBR = grid[y+1][x+1];
                        const vBL = grid[y+1][x];

                        if (vTL === null || vTR === null || vBR === null || vBL === null) continue;

                        const x0 = x * RES;
                        const y0 = y * RES;

                        steps.forEach(level => {
                            const minV = Math.min(vTL, vTR, vBR, vBL);
                            const maxV = Math.max(vTL, vTR, vBR, vBL);

                            if (level > minV && level <= maxV) {
                                const points = [];
                                if ((vTL < level && vTR >= level) || (vTL >= level && vTR < level)) {
                                    points.push({x: lerp(level, vTL, vTR, x0, x0 + RES), y: y0});
                                }
                                if ((vTR < level && vBR >= level) || (vTR >= level && vBR < level)) {
                                    points.push({x: x0 + RES, y: lerp(level, vTR, vBR, y0, y0 + RES)});
                                }
                                if ((vBR < level && vBL >= level) || (vBR >= level && vBL < level)) {
                                    points.push({x: x0 + RES, y: lerp(level, vBR, vBL, x0 + RES, x0), y: y0 + RES});
                                }
                                if ((vBL < level && vTL >= level) || (vBL >= level && vTL < level)) {
                                    points.push({x: x0, y: lerp(level, vBL, vTL, y0 + RES, y0)});
                                }

                                if (points.length === 2) {
                                    ctx.strokeStyle = getIsoColor(level, this.mode);
                                    ctx.beginPath();
                                    ctx.moveTo(points[0].x, points[0].y);
                                    ctx.lineTo(points[1].x, points[1].y);
                                    ctx.stroke();

                                    if (x % 10 === 0 && y % 10 === 0) {
                                        let displayText = "";
                                        if (this.mode === 'temp') {
                                            displayText = useCelsius ? Math.round(level).toString() : Math.round(level * 1.8 + 32).toString();
                                        } else {
                                            displayText = useHpa ? Math.round(level * 33.8639).toString() : level.toFixed(2);
                                        }

                                        labels.push({
                                            x: (points[0].x + points[1].x)/2,
                                            y: (points[0].y + points[1].y)/2,
                                            text: displayText
                                        });
                                    }
                                }
                            }
                        });
                    }
                }

                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                labels.forEach(l => {
                    const metrics = ctx.measureText(l.text);
                    const pad = 3;
                    const w = metrics.width + pad * 2;
                    const h = 14;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                    ctx.shadowBlur = 4;
                    ctx.fillRect(l.x - w/2, l.y - h/2, w, h);
                    ctx.shadowBlur = 0; 

                    ctx.fillStyle = 'black';
                    ctx.fillText(l.text, l.x, l.y);
                });
            }
        });
    }

    function updateMapWarnings() {
        const warningEl = document.getElementById('combinedWarning');
        const hasFreezing = !!freezingLayer;
        const hasHeatmap = !!heatmapLayer;

        if (hasFreezing || hasHeatmap) {
            warningEl.classList.remove('hidden');
        } else {
            warningEl.classList.add('hidden');
        }
    }

function toggleRunwayOnMap() {
    showRunwaysOnMap = !showRunwaysOnMap;
    const btn = document.getElementById('runwayMapBtn');
    
    if (showRunwaysOnMap) {
        btn.classList.add('runway-active'); // Uses the new standard class
        
        // Ensure data is loaded if this is the first click
        if (!cachedRunwayMap) {
            getRunwayData().then(() => {
                if (currentStationsData.length > 0) renderMap(currentStationsData);
            });
        }
    } else {
        btn.classList.remove('runway-active');
    }

    // Trigger re-render
    if (currentStationsData.length > 0) {
        renderMap(currentStationsData);
    }
    updateLayerActiveState();
}

    function toggleHeatmap() {
        const btn = document.getElementById('heatmapBtn');
        const legend = document.getElementById('heatmapLegend');
        const legendTitle = document.getElementById('legendTitle');
        const legendLabels = document.getElementById('legendLabels');

        if (!mapInstance) return;

        // Cycle Mode: Off (0) -> Temp (1) -> Pressure (2) -> Off (0)
        heatmapMode = (heatmapMode + 1) % 3;

        // 1. Remove Existing
        if (heatmapLayer) {
            mapInstance.removeLayer(heatmapLayer);
            heatmapLayer = null;
        }

        // 2. Handle New State
        if (heatmapMode === 0) {
            // OFF
            btn.classList.remove('bg-blue-100', 'text-blue-600', 'border-blue-500');
            btn.innerHTML = 'üå°Ô∏è';
            legend.style.display = 'none';
        }
        else if (heatmapMode === 1) {
            // TEMP (Iso-lines)
            btn.classList.add('bg-blue-100', 'text-blue-600');
            btn.innerHTML = 'üî•';

            // Setup Text Legend
            const unitStr = useCelsius ? '¬∞C' : '¬∞F';
            legend.style.display = 'flex';
            legendTitle.textContent = `Temp Lines (${unitStr})`;

            // Note: Legend values here are static ranges, just general guide
            legendLabels.innerHTML = `
                <span class="text-purple-600 font-bold">Cold</span> ‚Ä¢
                <span class="text-blue-600 font-bold">Cool</span> ‚Ä¢
                <span class="text-green-600 font-bold">Mild</span> ‚Ä¢
                <span class="text-red-500 font-bold">Hot</span>
            `;

            // Add Layer
            heatmapLayer = new L.WeatherIsoLayer({ mode: 'temp' });
            mapInstance.addLayer(heatmapLayer);
        }
        else if (heatmapMode === 2) {
            // PRESSURE (Iso-lines)
            btn.innerHTML = 'üéà';

            // Setup Text Legend
            const unitStr = useHpa ? 'hPa' : 'inHg';
            legend.style.display = 'flex';
            legendTitle.textContent = `Pressure Lines (${unitStr})`;
            legendLabels.innerHTML = `
                <span class="text-blue-600 font-bold">Low</span> ‚Ä¢
                <span class="text-red-600 font-bold">High</span>
            `;

            // Add Layer
            heatmapLayer = new L.WeatherIsoLayer({ mode: 'pressure' });
            mapInstance.addLayer(heatmapLayer);
        }

        updateMapWarnings();
        updateLayerActiveState(); // New logic
    }
// --- SAVED SETTINGS LOGIC ---

function saveLayerSettings() {
    const settings = {
        radar: !!radarRefreshInterval, // If interval exists, Radar is ON
        traffic: !!trafficRefreshInterval,
        runways: typeof showRunwaysOnMap !== 'undefined' ? showRunwaysOnMap : true,
        freezing: !!freezingLayer,
        heatmap: heatmapMode || 0,
        pireps: document.getElementById('pirepBtn')?.classList.contains('pirep-active') || false,
        hazards: !!hazardsRefreshInterval,
        daynight: !!dayNightInterval
    };
    try {
        localStorage.setItem('layerSettings', JSON.stringify(settings));
    } catch(e) { console.warn("Settings save failed", e); }
}

function loadLayerSettings() {
    let settings = null;
    try {
        settings = JSON.parse(localStorage.getItem('layerSettings'));
    } catch(e) {}

    // Default settings for a new user (First visit)
    if (!settings) {
        settings = {
            radar: true,      // Default ON
            daynight: true,   // Default ON
            runways: true,    // Default ON
            traffic: false,
            freezing: false,
            heatmap: 0,
            pireps: false,
            hazards: false
        };
    }

    // Apply Runways
    if (settings.runways !== showRunwaysOnMap) toggleRunwayOnMap();

    // Apply Radar
    const isRadarOn = !!radarRefreshInterval;
    if (settings.radar !== isRadarOn) toggleRadar();

    // Apply Day/Night
    const isDayNightOn = !!dayNightInterval;
    if (settings.daynight !== isDayNightOn) toggleDayNight();

    // Apply Traffic
    const isTrafficOn = !!trafficRefreshInterval;
    if (settings.traffic !== isTrafficOn) toggleTraffic();

    // Apply Hazards
    const isHazardsOn = !!hazardsRefreshInterval;
    if (settings.hazards !== isHazardsOn) toggleHazards();

    // Apply Freezing
    const isFreezingOn = !!freezingLayer;
    if (settings.freezing !== isFreezingOn) toggleFreezingLayer();

    // Apply PIREPs
    const isPirepOn = document.getElementById('pirepBtn')?.classList.contains('pirep-active');
    if (settings.pireps !== isPirepOn) togglePireps();

    // Apply Heatmap (Cycle mode until matching saved state)
    let target = settings.heatmap || 0;
    while (heatmapMode !== target) {
        toggleHeatmap();
    }
}

 function initMap() {
        if (mapInstance) return;

        const isDark = document.documentElement.classList.contains('dark');

        mapInstance = L.map('weatherMap', {
            preferCanvas: true,
            worldCopyJump: true,
            zoomControl: false
        }).setView([39.8283, -98.5795], 4);

        mapRenderer = L.canvas({ tolerance: 20 });

        tileLayer = L.tileLayer(isDark ? MAP_DARK_URL : MAP_LIGHT_URL, {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(mapInstance);

        // --- CUSTOM PANES ---
        mapInstance.createPane('heatmapPane');
        mapInstance.getPane('heatmapPane').style.zIndex = 200;

        mapInstance.createPane('dayNightPane');
        mapInstance.getPane('dayNightPane').style.zIndex = 225;
        mapInstance.getPane('dayNightPane').style.pointerEvents = 'none';

        mapInstance.createPane('radarPane');
        mapInstance.getPane('radarPane').style.zIndex = 250;
        mapInstance.getPane('radarPane').style.pointerEvents = 'none';

        mapInstance.createPane('userLocationPane');
        mapInstance.getPane('userLocationPane').style.zIndex = 350;
        mapInstance.getPane('userLocationPane').style.pointerEvents = 'none';

        mapInstance.createPane('routePane');
        mapInstance.getPane('routePane').style.zIndex = 400;
        mapInstance.getPane('routePane').style.pointerEvents = 'none';

        mapInstance.createPane('hazardPane');
        mapInstance.getPane('hazardPane').style.zIndex = 405; 

        mapInstance.createPane('markerPane');
        mapInstance.getPane('markerPane').style.zIndex = 600;

        mapInstance.createPane('pirepPane');
        mapInstance.getPane('pirepPane').style.zIndex = 625;
        
        mapInstance.createPane('trafficPane');
        mapInstance.getPane('trafficPane').style.zIndex = 650; 
        mapInstance.getPane('trafficPane').style.pointerEvents = 'none';

        // --- RENDERERS ---
        markerRenderer = L.svg({ pane: 'markerPane' });
        routeRenderer = L.canvas({ pane: 'routePane' });

        // Initialize Layer Groups
        markerLayerGroup = L.layerGroup().addTo(mapInstance);
        labelLayerGroup = L.layerGroup().addTo(mapInstance);

        // --- EVENT LISTENERS ---
        mapInstance.on('moveend', () => {
            updateMapLabels(); 
            if (currentStationsData && currentStationsData.length > 0) {
                renderMap(currentStationsData);
            }
        });
        
        mapInstance.on('click', () => {
    clearFlightPath();
});

        mapInstance.on('zoomend', () => {
           updateMapLabels();
           // Toggle Traffic Labels based on Zoom
           const currentZoom = mapInstance.getZoom();
           const mapEl = document.getElementById('weatherMap');
           if (currentZoom < 9) {
               mapEl.classList.add('hide-traffic-labels');
           } else {
               mapEl.classList.remove('hide-traffic-labels');
           }
        });

        // --- FREEZING LAYER DEFINITION ---
        if (typeof L.FreezingLayer === 'undefined') {
            L.FreezingLayer = L.Layer.extend({
                onAdd: function(map) {
                    this._map = map;
                    this._canvas = L.DomUtil.create('canvas', 'leaflet-freezing-layer');
                    this._canvas.style.pointerEvents = 'none';
                    this._canvas.style.zIndex = 300; 
                    map.getPanes().overlayPane.appendChild(this._canvas);

                    map.on('moveend', this._update, this);
                    map.on('zoomend', this._update, this); 
                    this._update();
                },
                onRemove: function(map) {
                    map.getPanes().overlayPane.removeChild(this._canvas);
                    map.off('moveend', this._update, this);
                    map.off('zoomend', this._update, this);
                },
                _update: function() {
                    if (!this._map) return;
                    const map = this._map;
                    const size = map.getSize();
                    const canvas = this._canvas;
                    canvas.width = size.x;
                    canvas.height = size.y;
                    const bounds = map.getBounds();
                    const topLeft = map.latLngToLayerPoint(bounds.getNorthWest());
                    L.DomUtil.setPosition(canvas, topLeft);
                    this._draw();
                },
                _draw: function() {
                    const ctx = this._canvas.getContext('2d');
                    const width = this._canvas.width;
                    const height = this._canvas.height;
                    const map = this._map;
                    ctx.clearRect(0, 0, width, height);
                    if (!allStationsData || allStationsData.length === 0) return;
                    const bounds = map.getBounds();
                    const pad = 15.0;
                    const south = bounds.getSouth() - pad;
                    const north = bounds.getNorth() + pad;

                    const relevantStations = allStationsData.filter(s =>
                        s.latitude !== null && s.longitude !== null &&
                        s.latitude >= south && s.latitude <= north &&
                        s.metar && s.metar.rawTempC !== null && !isNaN(s.metar.rawTempC)
                    );

                    if (relevantStations.length < 5) return;
                    const RES = 15;
                    const cols = Math.ceil(width / RES);
                    const rows = Math.ceil(height / RES);
                    const stationData = relevantStations.map(s => ({
                        lat: s.latitude,
                        lon: s.longitude,
                        temp: s.metar.rawTempC
                    }));

                    ctx.fillStyle = 'rgba(6, 182, 212, 0.25)'; 
                    const NEIGHBOR_COUNT = 5;

                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            const px = x * RES;
                            const py = y * RES;
                            const ll = map.containerPointToLatLng(L.point(px + RES/2, py + RES/2));
                            const cosLat = Math.cos(ll.lat * Math.PI / 180);
                            let closest = [];
                            for (let i = 0; i < stationData.length; i++) {
                                const s = stationData[i];
                                const dLat = s.lat - ll.lat;
                                let rawDiff = Math.abs(s.lon - ll.lng);
                                if (rawDiff > 180) rawDiff = 360 - rawDiff;
                                const dLon = rawDiff * cosLat;
                                const distSq = dLat*dLat + dLon*dLon;
                                if (closest.length < NEIGHBOR_COUNT) {
                                    closest.push({ distSq: distSq, temp: s.temp });
                                    closest.sort((a,b) => a.distSq - b.distSq);
                                } else if (distSq < closest[NEIGHBOR_COUNT-1].distSq) {
                                    closest[NEIGHBOR_COUNT-1] = { distSq: distSq, temp: s.temp };
                                    closest.sort((a,b) => a.distSq - b.distSq);
                                }
                            }
                            let sumWeights = 0;
                            let weightedTemp = 0;
                            for(let i=0; i<closest.length; i++) {
                                const w = 1 / (closest[i].distSq + 0.000001);
                                weightedTemp += closest[i].temp * w;
                                sumWeights += w;
                            }
                            if (sumWeights > 0) {
                                const estimatedTemp = weightedTemp / sumWeights;
                                if (estimatedTemp < 0) ctx.fillRect(px, py, RES, RES);
                            }
                        }
                    }
                }
            });
        }

        // --- LOAD SAVED SETTINGS ---
        // This replaces the old hardcoded defaults
        loadLayerSettings();
    }

    // --- DAY/NIGHT LOGIC ---
    function getTerminatorCoords(time) {
        // Solar position calculation helper
        // Constants
        const PI = Math.PI;
        const RAD = PI / 180;
        const DEG = 180 / PI;

        // Julian date (Strict UTC)
        const julianDay = (time.getTime() / 86400000) + 2440587.5;
        const D = julianDay - 2451545.0;

        // Mean Anomaly / Ecliptic Longitude
        const g = (357.529 + 0.98560028 * D) % 360;
        const q = (280.459 + 0.98564736 * D) % 360;
        const L = (q + 1.915 * Math.sin(g * RAD) + 0.020 * Math.sin(2 * g * RAD)) % 360;

        // Sun Declination
        const epsilon = 23.439 - 0.00000036 * D;
        const ra = Math.atan2(Math.cos(epsilon * RAD) * Math.sin(L * RAD), Math.cos(L * RAD)) * DEG;
        const dec = Math.asin(Math.sin(epsilon * RAD) * Math.sin(L * RAD)) * DEG;

        // Greenwich Hour Angle
        const gha = (15 * (time.getUTCHours() + time.getUTCMinutes() / 60 + time.getUTCSeconds() / 3600) - 180) + ra; // Adjusted offset

        // Equation of time
        const eot = (q / 15 - ra / 15); // Not strictly needed for shadow but good for solar position

        // Sun Position (Sub-solar point)
        // Lat = dec
        // Lon = -15 * (UTC_time - 12 + eot) ... simplified:
        const sunLon = -(15 * (time.getUTCHours() + time.getUTCMinutes() / 60 + time.getUTCSeconds() / 3600) - 180); // Rough GHA

        // Antipode (Center of Night)
        const antiLat = -dec;
        const antiLon = (sunLon + 180) % 360; // Keep within range

        // Compute circle of illumination (The terminator)
        // Spherical law of cosines: cos(c) = cos(a)cos(b) + sin(a)sin(b)cos(C)
        // For terminator (90 deg from sun): cos(90) = 0
        // 0 = sin(lat)*sin(dec) + cos(lat)*cos(dec)*cos(lon_diff)
        // tan(lat) = -cos(lon_diff) / tan(dec)

        const latLngs = [];
        // Generate terminator points
        // We'll calculate the latitude of the terminator for every longitude degree relative to the sun
        const sunLatRad = dec * RAD;
        // Shift longitude relative to GHA (Sun's longitude is roughly -(15 * (UTC time)) )
        // Actually, precise: Sun's Lon = - (Greenwich Sidereal Time - Right Ascension)
        // Simplified approach: Calculate GST
        const GMST = (18.697374558 + 24.06570982441908 * D) % 24;
        const sunLonActual = (ra - GMST * 15);

        for (let i = 0; i <= 360; i+=2) {
            const lon = i - 180;
            const lonRad = (lon - sunLonActual) * RAD;
            const latRad = Math.atan(-Math.cos(lonRad) / Math.tan(sunLatRad));
            latLngs.push([latRad * DEG, lon]);
        }

        // Close the polygon to cover the night side
        // We need to extend the polygon to cover either the North or South pole depending on season
        // If Sun is North (positive dec), North pole is lit, South pole is dark.
        // We draw the shadow, so cover South.
        // If Sun is South (negative dec), North pole is dark.

        const isNorthSummer = (dec > 0);
        if (isNorthSummer) {
            // Sun North -> Shadow covers South Pole
            latLngs.push([-90, 180]);
            latLngs.push([-90, -180]);
        } else {
            // Sun South -> Shadow covers North Pole
            latLngs.push([90, 180]);
            latLngs.push([90, -180]);
        }

        // Ensure closure
        latLngs.push(latLngs[0]);

        return latLngs;
    }

    function toggleDayNight() {
        const btn = document.getElementById('dayNightBtn');

        if (dayNightInterval) {
            // Turn OFF
            clearInterval(dayNightInterval);
            dayNightInterval = null;
            if (dayNightLayer && mapInstance) {
                mapInstance.removeLayer(dayNightLayer);
            }
            dayNightLayer = null;
            btn.classList.remove('daynight-active');
        } else {
            // Turn ON
            btn.classList.add('daynight-active');

            const updateShadow = () => {
                if (!mapInstance) return;

                const coords = getTerminatorCoords(new Date());

                if (dayNightLayer) {
                    mapInstance.removeLayer(dayNightLayer);
                }

                // Create copies for West (-360) and East (+360)
                const coordsWest = coords.map(p => [p[0], p[1] - 360]);
                const coordsEast = coords.map(p => [p[0], p[1] + 360]);

                // Render as one multi-polygon
                dayNightLayer = L.polygon([coordsWest, coords, coordsEast], {
                    color: 'transparent',
                    fillColor: '#000',
                    fillOpacity: 0.35, 
                    pane: 'dayNightPane', 
                    interactive: false,
                    smoothFactor: 1.0
                }).addTo(mapInstance);
            };

            updateShadow();
            dayNightInterval = setInterval(updateShadow, 60000);
        }

        updateLayerActiveState();
    }


    // --- RADAR LOGIC ---
    async function updateRadarLayer() {
        const timeDisplay = document.getElementById('radarTimeDisplay');

        try {
            // 1. Fetch latest timestamp from RainViewer DIRECTLY
            const res = await fetch('https://api.rainviewer.com/public/weather-maps.json');
            const data = await res.json();

            if (data && data.radar && data.radar.past && data.radar.past.length > 0) {
                const lastFrame = data.radar.past[data.radar.past.length - 1];
                const time = lastFrame.time;
                const host = data.host;

                // Reverting to classic method: Remove old, add new.
                // This is robust against event listener failures.
                if (radarLayer) {
                    mapInstance.removeLayer(radarLayer);
                }

                radarLayer = L.tileLayer(`${host}/v2/radar/${time}/256/{z}/{x}/{y}/2/1_1.png`, {
                    pane: 'radarPane',
                    opacity: 0.8,
                    maxZoom: 10,
                    attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>'
                });

                radarLayer.addTo(mapInstance);

                // 3. Update Timestamp
                const date = new Date(time * 1000);
                const h = String(date.getUTCHours()).padStart(2, '0');
                const m = String(date.getUTCMinutes()).padStart(2, '0');
                timeDisplay.textContent = `Radar: ${h}:${m}Z`;
                timeDisplay.style.display = 'block';
            }
        } catch (err) {
            console.error("Radar update failed", err);
            timeDisplay.textContent = "Radar Error";
        }
    }

    function toggleRadar() {
        const btn = document.getElementById('radarToggleBtn');
        const timeDisplay = document.getElementById('radarTimeDisplay');

        if (radarRefreshInterval) {
            // --- TURN OFF ---
            clearInterval(radarRefreshInterval);
            radarRefreshInterval = null;

            if (radarLayer) {
                mapInstance.removeLayer(radarLayer);
                radarLayer = null;
            }
            btn.classList.remove('radar-active');
            timeDisplay.style.display = 'none';
        } else {
            // --- TURN ON ---
            btn.classList.add('radar-active');
            timeDisplay.textContent = 'Loading Radar...';
            timeDisplay.style.display = 'block';

            // Initial Load
            updateRadarLayer();

            // Set Auto-Refresh (every 5 minutes)
            radarRefreshInterval = setInterval(updateRadarLayer, 300000);
        }
        updateLayerActiveState(); // New logic
    }

async function updateHazardsLayer() {
    if (!mapInstance) return;

    if (hazardsLayer) {
        mapInstance.removeLayer(hazardsLayer);
        hazardsLayer = null;
    }

    try {
        const [usRes, intlRes] = await Promise.all([
            fetch(SIGMET_DOMESTIC_URL),
            fetch(SIGMET_INTL_URL)
        ]);

        const usData = usRes.ok ? await usRes.json() : { features: [] };
        const intlData = intlRes.ok ? await intlRes.json() : { features: [] };

        const mergedFeatures = [...(usData.features || []), ...(intlData.features || [])];
        const mergedGeoJSON = { type: "FeatureCollection", features: mergedFeatures };

        if (mergedFeatures.length === 0) {
            console.warn("No SIGMETs found.");
        }

        const hazardRenderer = L.svg({ pane: 'hazardPane' });
        const hazardGroup = L.layerGroup();
        
        // Render 3 copies: Main, West, East
        [-360, 0, 360].forEach(offset => {
            const layer = L.geoJSON(mergedGeoJSON, {
                pane: 'hazardPane',
                renderer: hazardRenderer, 
                interactive: true,
                // Magic trick: shift coordinates on the fly during parsing
                coordsToLatLng: function (coords) {
                    return new L.LatLng(coords[1], coords[0] + offset, coords[2]);
                },
                style: function (feature) {
                    const hazard = feature.properties.hazard || '';
                    const qual = feature.properties.qualifier || '';
                    let color = '#888888';
                    let dashArray = null;
                    let weight = 2;
                    if (hazard === 'TS' || qual === 'CONVECTIVE') { color = '#ef4444'; weight = 3; }
                    else if (hazard === 'TURB') { color = '#f97316'; dashArray = '5, 10'; }
                    else if (hazard === 'ICE') { color = '#3b82f6'; }
                    else if (hazard === 'ASH' || hazard === 'VA') { color = '#4b5563'; }
                    return { color, weight, opacity: 0.9, fillOpacity: 0.2, dashArray };
                },
                onEachFeature: function (feature, layer) {
                    const props = feature.properties;
                    const hazardType = props.hazard || 'Unknown';
                    const raw = props.rawSigmet || props.rawAirSigmet || props.raw || 'No details';
                    const validTo = props.validTimeTo || '';

                    layer.on('mouseover', function() { this.setStyle({ weight: 4, fillOpacity: 0.4 }); });
                    layer.on('mouseout', function() { layer.resetStyle(this); }); // Fixed reference

                    layer.bindPopup(`
                        <div class="font-sans min-w-[200px]">
                            <div class="font-bold text-sm mb-1 border-b pb-1">SIGMET: ${hazardType}</div>
                            <div class="text-xs font-mono bg-gray-100 dark:bg-gray-800 p-1 mb-2 whitespace-pre-wrap">${raw}</div>
                            <div class="text-xs text-gray-500">Valid until: ${validTo}</div>
                        </div>
                    `);
                }
            });
            hazardGroup.addLayer(layer);
        });

        hazardsLayer = hazardGroup.addTo(mapInstance);

    } catch (e) {
        console.warn("Failed to fetch Hazards", e);
        const btn = document.getElementById('hazardsBtn');
        if(btn) btn.classList.remove('hazard-active');
    } finally {
        const btn = document.getElementById('hazardsBtn');
        if(btn) btn.innerHTML = '‚ö†Ô∏è';
    }
}

   async function updatePireps() {
        if (!mapInstance) return;

        if (pirepLayer) {
            mapInstance.removeLayer(pirepLayer);
        }

        try {
            const pirepDoc = await fetchAndParse(PIREP_DATA_URL);
            const reports = [];

            pirepDoc.querySelectorAll("AircraftReport").forEach(node => {
                const lat = parseFloat(node.querySelector("latitude")?.textContent);
                const lon = parseFloat(node.querySelector("longitude")?.textContent);
                if (isNaN(lat) || isNaN(lon)) return;

                const type = node.querySelector("report_type")?.textContent || "UA"; 
                const aircraft = node.querySelector("aircraft_ref")?.textContent || "Unknown";
                const time = node.querySelector("observation_time")?.textContent;
                const rawText = node.querySelector("raw_text")?.textContent || "";

                let turbInt = null;
                const turbNode = node.querySelector("turbulence_condition");
                if (turbNode) turbInt = turbNode.getAttribute("turbulence_intensity");

                let icingInt = null;
                const icingNode = node.querySelector("icing_condition");
                if (icingNode) icingInt = icingNode.getAttribute("icing_intensity");

                reports.push({ lat, lon, type, aircraft, time, rawText, turbInt, icingInt });
            });

            const markers = [];
            const offsets = [-360, 0, 360]; // Replicate across worlds

            reports.forEach(rep => {
                let svgContent = '';
                let color = '#fb923c'; 
                const isUrgent = (rep.type === 'UUA');
                if (isUrgent) color = '#ef4444'; 

                if (rep.icingInt && (rep.icingInt.includes('LGT') || rep.icingInt.includes('MOD') || rep.icingInt.includes('SEV'))) {
                    if (rep.icingInt.includes('SEV')) {
                        color = '#ef4444'; 
                        svgContent = `<path d="M3 6 L3 12 A5 5 0 0 0 13 12 L13 6 M6 6 L6 14 M10 6 L10 14" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                    } else if (rep.icingInt.includes('MOD')) {
                        color = '#f97316'; 
                         svgContent = `<path d="M3 6 L3 12 A5 5 0 0 0 13 12 L13 6 M8 6 L8 14" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                    } else { 
                        color = '#22c55e'; 
                        svgContent = `<path d="M4 6 L4 12 A4 4 0 0 0 12 12 L12 6" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                    }
                }
                else if (rep.turbInt && (rep.turbInt.includes('LGT') || rep.turbInt.includes('MOD') || rep.turbInt.includes('SEV') || rep.turbInt.includes('EXTRM'))) {
                    if (rep.turbInt.includes('SEV') || rep.turbInt.includes('EXTRM')) {
                         color = '#ef4444'; 
                         svgContent = `<path d="M4 12 L8 5 L12 12 M4 7 L8 0 L12 7" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                    } else if (rep.turbInt.includes('MOD')) {
                         color = '#f97316'; 
                         svgContent = `<path d="M3 13 L8 4 L13 13" fill="none" stroke="${color}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>`;
                    } else { 
                         color = '#22c55e'; 
                         svgContent = `<path d="M4 12 L8 6 L12 12" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
                    }
                }
                else if (rep.rawText.includes('NEG') || rep.rawText.includes('NIL')) {
                     color = '#3b82f6';
                     svgContent = `<circle cx="8" cy="8" r="6" stroke="${color}" stroke-width="2" fill="none"/><line x1="4" y1="12" x2="12" y2="4" stroke="${color}" stroke-width="2"/>`;
                }
                else {
                    color = '#ffffff'; 
                    svgContent = `<g transform="rotate(45 8 8)"><path d="M8 1 L10 6 L15 8 L15 10 L10 9 L10 13 L12 15 L12 16 L8 15 L4 16 L4 15 L6 13 L6 9 L1 10 L1 8 L6 6 Z" fill="${color}" stroke="black" stroke-width="0.5"/></g>`;
                }

                const iconHtml = `
                    <svg width="20" height="20" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="overflow: visible;">
                        ${isUrgent ? `<circle cx="8" cy="8" r="9" fill="rgba(239, 68, 68, 0.3)" stroke="red" stroke-width="1" />` : ''}
                        ${svgContent}
                    </svg>
                `;

                const icon = L.divIcon({
                    className: 'pirep-icon',
                    html: iconHtml,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                // LOOP over offsets to place 3 markers
                offsets.forEach(offset => {
                    const marker = L.marker([rep.lat, rep.lon + offset], {
                        icon: icon,
                        pane: 'pirepPane',
                        zIndexOffset: isUrgent ? 1000 : 0,
                        interactive: true 
                    });

                    const age = calculateAgeInMinutes(rep.time);
                    const ageText = formatAge(age);

                    marker.bindPopup(`
                        <div class="font-sans min-w-[200px]">
                            <div class="flex items-center justify-between border-b pb-1 mb-2">
                                <span class="font-bold ${isUrgent ? 'text-red-600' : 'text-blue-600'}">
                                    ${rep.type} PIREP
                                </span>
                                <span class="text-xs text-gray-500">${ageText}</span>
                            </div>
                            <div class="text-sm font-bold mb-1">${rep.aircraft}</div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-2 rounded text-xs font-mono mb-2 whitespace-pre-wrap">${rep.rawText}</div>
                            ${rep.turbInt ? `<div class="text-xs"><span class="font-bold">Turb:</span> ${rep.turbInt}</div>` : ''}
                            ${rep.icingInt ? `<div class="text-xs"><span class="font-bold">Icing:</span> ${rep.icingInt}</div>` : ''}
                        </div>
                    `);

                    markers.push(marker);
                });
            });

            pirepLayer = L.layerGroup(markers).addTo(mapInstance);

        } catch (e) {
            console.warn("Failed to fetch PIREPs", e);
            document.getElementById('pirepBtn').classList.remove('pirep-active');
        } finally {
            const btn = document.getElementById('pirepBtn');
            if (btn.textContent === '...') btn.innerHTML = '‚úàÔ∏è'; 
        }
    }
// --- GLOBAL VARIABLES (Add these at the top of your script if missing) ---

// let hazardsLayer = null; // (This should already be defined with your other layers)

// --- HAZARDS TOGGLE FUNCTION ---
function toggleHazards() {
    const btn = document.getElementById('hazardsBtn');
    if (!mapInstance) return;

    if (hazardsRefreshInterval) {
        // --- TURN OFF ---
        clearInterval(hazardsRefreshInterval);
        hazardsRefreshInterval = null;

        if (hazardsLayer) {
            mapInstance.removeLayer(hazardsLayer);
            hazardsLayer = null;
        }

        btn.classList.remove('hazard-active');
        btn.innerHTML = '‚ö†Ô∏è'; // Restore icon
    } else {
        // --- TURN ON ---
        btn.classList.add('hazard-active');
        // Show spinner
        btn.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;

        updateHazardsLayer(); // Initial call
        // Auto-refresh every 5 minutes
        hazardsRefreshInterval = setInterval(updateHazardsLayer, 300000);
    }
    updateLayerActiveState();
}
    function togglePireps() {
        const btn = document.getElementById('pirepBtn');
        const attrib = document.getElementById('pirepAttribution');
        if (!mapInstance) return;

        if (pirepLayer) {
            // OFF
            mapInstance.removeLayer(pirepLayer);
            pirepLayer = null;
            btn.classList.remove('pirep-active');
            if(attrib) attrib.classList.add('hidden');
        } else {
            // ON
            btn.classList.add('pirep-active');
            if(attrib) attrib.classList.remove('hidden');
            btn.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
            setTimeout(() => {
                updatePireps().then(() => {
                     if(btn.classList.contains('pirep-active')) btn.innerHTML = '‚úàÔ∏è';
                });
            }, 50);
        }
        updateLayerActiveState(); // New logic
    }

// --- TRAFFIC (ADS-B) LOGIC ---
// UPDATED: Accepts 'altText' string instead of raw number
function getTrafficIcon(track, flight, altText, gs, vs) {
    const spd = (gs !== undefined && gs !== null) ? Math.round(gs) : '...';
    
    let trend = '';
    if (vs > 500) trend = '‚ñ≤'; 
    else if (vs < -500) trend = '‚ñº';

    // HTML now uses the passed 'altText' directly (e.g., "FL350" or "4500ft")
    // REPLACE the existing iconHtml line in getTrafficIcon with this:

const iconHtml = `
<div class="atc-container">
    <!-- The Chevron SVG -->
    <svg style="transform: rotate(${track}deg); width: 20px; height: 20px; margin-top: -4px; margin-left: -4px; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2L22 22L12 18L2 22L12 2Z" fill="#10b981" stroke="white" stroke-width="1.5" stroke-linejoin="round"/>
    </svg>
    <div class="atc-label" style="left: 14px; top: -2px;">${flight}<span>${altText}${trend} ${spd}</span></div>
</div>`;

    return L.divIcon({
        className: 'bg-transparent',
        html: iconHtml,
        iconSize: [12, 12], 
        iconAnchor: [6, 6] 
    });
}

async function updateTrafficLayer() {
    if (!mapInstance) return;

    try {
        const center = mapInstance.getCenter();
        const bounds = mapInstance.getBounds();
        const northEast = bounds.getNorthEast();
        
        // 1. Calculate Radius
        const radiusDeg = Math.max(Math.abs(northEast.lat - center.lat), Math.abs(northEast.lng - center.lng));
        const radiusNm = Math.min(Math.ceil(radiusDeg * 60 * 1.5), 250); 

        // 2. Fetch Traffic
        const targetUrl = `https://api.airplanes.live/v2/point/${center.lat.toFixed(4)}/${center.lng.toFixed(4)}/${radiusNm}?cb=${Date.now()}`;
        
        const res = await fetch(targetUrl);
        if (!res.ok) return; 
        const data = await res.json();
        const aircraft = data.ac || data.aircraft; 
        if (!aircraft) return;

        const seenIds = new Set();

        aircraft.forEach(ac => {
            if (!ac.lat || !ac.lon) return;

            const hex = ac.hex;
            const flight = ac.flight ? ac.flight.trim() : (ac.r || hex);
            const alt = ac.alt_baro;
            const gs = ac.gs;
            const track = ac.track; // Usually True Track
            const vs = ac.baro_rate;
            
            // New Data Fields
            const type = ac.t; // Aircraft Type
            const squawk = ac.squawk;
            const ias = ac.ias;
            const tas = ac.tas;
            const magHeading = ac.mag_heading;
            const trueHeading = ac.true_heading;
            const windDir = ac.wd; // Wind Direction
            const windSpd = ac.ws; // Wind Speed
            
            seenIds.add(hex);

            // --- 3. PER-TRACK QNH & TRANSITION LOGIC ---
            let localQnhInHg = null;
            let transitionAlt = 6000; // Default Global TA
            
            if (typeof allStationsData !== 'undefined' && allStationsData.length > 0) {
                let minDist = Infinity;
                let nearestStation = null;

                for (const s of allStationsData) {
                    if (s.latitude === null || s.longitude === null || !s.metar || s.metar.altimInHg === null) continue;
                    
                    const dLat = s.latitude - ac.lat;
                    const dLon = s.longitude - ac.lon;
                    const distSq = dLat*dLat + dLon*dLon;
                    
                    if (distSq < minDist) {
                        minDist = distSq;
                        nearestStation = s;
                        localQnhInHg = s.metar.altimInHg;
                    }
                }

                if (nearestStation) {
                    const id = nearestStation.id;
                    if (id.startsWith('K') || id.startsWith('C') || id.startsWith('P') || id.startsWith('T')) {
                        transitionAlt = 18000;
                    }
                }
            }

            // --- ALTITUDE DISPLAY CALCULATION ---
            let altDisplay = "---"; // Full string for Popup
            let altLabel = "ALT";   // Label for Popup
            let tagAlt = "---";     // Short string for Map Icon

            if (alt === 'ground') {
                altDisplay = "Ground";
                tagAlt = "Gnd";
                altLabel = "POS";
            } 
            else if (typeof alt === 'number') {
                if (alt >= transitionAlt) {
                    // Above Transition: Flight Level
                    const flVal = Math.round(alt / 100);
                    altDisplay = "FL" + flVal;
                    tagAlt = "FL" + flVal;
                    altLabel = "FL";
                } else if (localQnhInHg) {
                    // Below Transition: QNH Corrected
                    const correction = (localQnhInHg - 29.92) * 1000;
                    const msl = alt + correction;
                    altDisplay = Math.round(msl).toLocaleString() + " ft";
                    tagAlt = Math.round(msl) + "ft";
                    altLabel = "MSL";
                } else {
                    // Fallback
                    altDisplay = alt.toLocaleString() + " ft";
                    tagAlt = alt + "ft";
                    altLabel = "STD";
                }
            }

            // --- BUILD POPUP CONTENT DYNAMICALLY ---
            let detailsHtml = '';

            // 1. Aircraft Type
            if (type) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">TYPE</span><span class="font-bold">${type}</span></div>`;
            }

            // 2. Altitude (Always show if available)
            detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">${altLabel}</span><span class="font-bold">${altDisplay}</span></div>`;

            // 3. Vertical Speed
            if (vs !== undefined && vs !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">V/S</span><span class="font-bold">${vs} fpm</span></div>`;
            }

            // 4. Track (Ground Track)
            if (track !== undefined && track !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">TRK</span><span class="font-bold">${Math.round(track)}¬∞T</span></div>`;
            }

            // 5. Heading (Prefer Magnetic, fallback to True)
            if (magHeading !== undefined && magHeading !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">HDG</span><span class="font-bold">${Math.round(magHeading)}¬∞M</span></div>`;
            } else if (trueHeading !== undefined && trueHeading !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">HDG</span><span class="font-bold">${Math.round(trueHeading)}¬∞T</span></div>`;
            }

            // 6. Ground Speed
            if (gs !== undefined && gs !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">GS</span><span class="font-bold">${Math.round(gs)} kts</span></div>`;
            }

            // 7. Indicated Airspeed
            if (ias !== undefined && ias !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">IAS</span><span class="font-bold">${Math.round(ias)} kts</span></div>`;
            }

            // 8. True Airspeed
            if (tas !== undefined && tas !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">TAS</span><span class="font-bold">${Math.round(tas)} kts</span></div>`;
            }

            // 9. Wind (Calculated)
            if (windDir !== undefined && windDir !== null && windSpd !== undefined && windSpd !== null) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">WIND</span><span class="font-bold">${Math.round(windDir)}¬∞ @ ${Math.round(windSpd)} kts</span></div>`;
            }

            // 10. Squawk
            if (squawk) {
                detailsHtml += `<div class="flex justify-between gap-4"><span class="text-gray-400 text-[10px]">SQ</span><span class="font-bold font-mono">${squawk}</span></div>`;
            }

            const icon = getTrafficIcon(track || 0, flight, tagAlt, gs, vs);

            const popupContent = `
                <div class="font-mono text-xs leading-none">
                    <div class="font-bold bg-blue-600 text-white px-2 py-1 rounded-t mb-0.5">${flight}</div>
                    <div class="px-2 pb-1 space-y-1 text-gray-700 dark:text-gray-200">
                        ${detailsHtml}
                    </div>
                </div>
            `;

            if (trafficMarkers.has(hex)) {
                const marker = trafficMarkers.get(hex);
                marker.setLatLng([ac.lat, ac.lon]);
                marker.setIcon(icon);
                marker.setPopupContent(popupContent);
            } else {
                const marker = L.marker([ac.lat, ac.lon], {
                    icon: icon,
                    pane: 'trafficPane',
                    zIndexOffset: 1000 
                });

                marker.bindPopup(popupContent, { 
                    closeButton: false, 
                    autoPan: false,
                    className: 'traffic-popup-compact', 
                    offset: [0, -5]
                });

                // --- CLICK LISTENER ---
                marker.on('click', () => {
                    fetchAndDrawTrace(hex);
                });
                
                if (trafficLayer) {
                    trafficLayer.addLayer(marker);
                    trafficMarkers.set(hex, marker);
                }
            }
        });

        // Cleanup
        trafficMarkers.forEach((marker, hex) => {
            if (!seenIds.has(hex)) {
                if (trafficLayer) trafficLayer.removeLayer(marker);
                trafficMarkers.delete(hex);
            }
        });

    } catch (e) {
        console.warn("Traffic error", e);
    }
    
    // --- AUTO-REFRESH TRACE ---
    // If a plane is selected, refresh its path to match the new position
    if (selectedAircraftHex) fetchAndDrawTrace(selectedAircraftHex);
}

function toggleTraffic() {
    const btn = document.getElementById('trafficBtn');
    const creditEl = document.getElementById('adsbCredit'); // <--- Get Element
    
    if(!mapInstance) return;

    if (trafficRefreshInterval) {
        // --- TURN OFF ---
        clearInterval(trafficRefreshInterval);
        trafficRefreshInterval = null;
        
        if(trafficLayer) {
            mapInstance.removeLayer(trafficLayer);
            trafficLayer = null;
        }
        trafficMarkers.clear();
        
        btn.classList.remove('traffic-active');
        if (creditEl) creditEl.classList.add('hidden'); // <--- HIDE CREDIT
    } else {
        // --- TURN ON ---
        btn.classList.add('traffic-active');
        if (creditEl) creditEl.classList.remove('hidden'); // <--- SHOW CREDIT
        
        trafficLayer = L.layerGroup().addTo(mapInstance);
        
        // Initial update
        updateTrafficLayer();
        
        // 5 second polling
        trafficRefreshInterval = setInterval(updateTrafficLayer, 5000);
    }
    updateLayerActiveState();
}

    function toggleFreezingLayer() {
        const btn = document.getElementById('freezingBtn');

        if (!mapInstance) return;

        if (freezingLayer) {
            // Turn Off
            mapInstance.removeLayer(freezingLayer);
            freezingLayer = null;
            btn.classList.remove('freezing-active');
        } else {
            // Turn On
            // Show loading state briefly
            btn.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;

            // Allow UI to update before running heavy calc
            setTimeout(() => {
                if(typeof L.FreezingLayer !== 'undefined') {
                    freezingLayer = new L.FreezingLayer();
                    mapInstance.addLayer(freezingLayer);
                    btn.classList.add('freezing-active');
                    btn.innerHTML = 'üßä';
                }
            }, 50);
        }
        updateMapWarnings();
        updateLayerActiveState(); // New logic
    }

    // --- USER LOCATION MARKER HELPER ---
    function updateUserLocationMarker(lat, lon) {
        if (!mapInstance) return;

        // Remove old marker if exists
        if (userLocationMarker) {
            mapInstance.removeLayer(userLocationMarker);
        }

        // Create Blue Dot Marker using DivIcon with CSS animation
        const userIcon = L.divIcon({
            className: 'user-location-marker',
            iconSize: [12, 12], // Reduced Size
            iconAnchor: [6, 6]  // Adjusted anchor
        });

        userLocationMarker = L.marker([lat, lon], {
            icon: userIcon,
            pane: 'userLocationPane', // Uses our custom Z-Index pane (350)
            interactive: false // Don't block clicks
        }).addTo(mapInstance);
    }

    // --- GPS / IP LOCATION LOGIC (STRICT GPS ONLY) ---
    function centerOnGPS() {
        const btn = document.getElementById('gpsBtn');
        const originalText = btn.textContent;

        btn.disabled = true;
        btn.textContent = "...";

        // Primary: GPS (Navigator) - STRICTLY GPS
        if (!navigator.geolocation) {
            alert("GPS not supported by this browser.");
            btn.disabled = false;
            btn.textContent = originalText;
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;

                // Show on map
                updateUserLocationMarker(lat, lon);
                if (mapInstance) {
                    mapInstance.flyTo([lat, lon], 10);
                }

                btn.disabled = false;
                btn.textContent = originalText;
            },
            (error) => {
                console.warn("GPS failed/denied.", error);
                // ERROR MESSAGE REMOVED PER USER REQUEST
                btn.disabled = false;
                btn.textContent = originalText;
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }

    // --- HOME BY GPS LOGIC (STRICT GPS ONLY) ---

    // Helper function to handle input focus (auto clear -GPS-)
    function handleInputFocus(el) {
        if (el.value === "-GPS-") {
            el.value = "";
            el.classList.remove('gps-active-input');
            gpsReferenceCoords = null;
        }
    }

    function setHomeToGPS() {
        // Reset manual input
        gpsReferenceCoords = null;

        const btn = document.getElementById('gpsHomeBtn');
        const input = document.getElementById('icaoInput');
        const originalContent = btn.innerHTML;

        // Show loading spinner icon on button
        btn.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
        btn.disabled = true;

        // Primary: GPS (Navigator) - STRICTLY GPS
        if (!navigator.geolocation) {
             alert("GPS not supported.");
             btn.innerHTML = originalContent;
             btn.disabled = false;
             return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;

                // 1. Set Global Reference
                gpsReferenceCoords = { lat: lat, lon: lon };

                // 2. Update Input UI
                input.value = "-GPS-";
                input.classList.add('gps-active-input');

                // 3. Ensure Map is Initialized (if this is first action)
                if (!mapInstance) initMap();

                // 4. Place "You are here" marker on map and fly there
                updateUserLocationMarker(lat, lon);
                if (mapInstance) {
                     mapInstance.flyTo([lat, lon], 10);
                }

                // 5. Regenerate Report with new coordinates
                handleGenerateClick(null, false);

                // 6. Restore button
                btn.innerHTML = originalContent;
                btn.disabled = false;

                // 7. Ensure Map View is Visible (Scroll to it)
                setTimeout(() => {
                    resultsContainerEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            },
            (error) => {
                console.warn("GPS failed/denied.", error);
                // ERROR MESSAGE REMOVED PER USER REQUEST
                btn.innerHTML = originalContent;
                btn.disabled = false;
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
    }

    // Clear GPS mode if user types in the box manually (backup listener)
    icaoInput.addEventListener('input', () => {
        if (gpsReferenceCoords !== null) {
            gpsReferenceCoords = null;
            icaoInput.classList.remove('gps-active-input');
        }
    });

    // --- WAKE LOCK (PREVENT SLEEP) ---
    async function requestWakeLock() {
        if ('wakeLock' in navigator) {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock active');
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }
    }

    function releaseWakeLock() {
        if (wakeLock !== null) {
            wakeLock.release()
                .then(() => {
                    wakeLock = null;
                    console.log('Wake Lock released');
                });
        }
    }

    // Re-acquire lock if visibility changes (e.g. user tabs out and back in)
    document.addEventListener('visibilitychange', async () => {
        const mapView = document.getElementById('mapView');
        if (wakeLock !== null && document.visibilityState === 'visible' && mapView.classList.contains('fullscreen-active')) {
            await requestWakeLock();
        }
    });

    // --- OPTIMIZED LABEL RENDERING ---
    // Instead of creating 5000 DOM elements (tooltip) which kills performance,
    // we only draw labels for stations currently inside the viewport, and only when zoomed in.
 // --- OPTIMIZED LABEL RENDERING ---
function updateMapLabels() {
    if (!mapInstance || !labelLayerGroup) return;

    // 1. Clear existing labels immediately to free memory
    labelLayerGroup.clearLayers();

    // 2. Check zoom level (Only show if >= 7)
    const zoom = mapInstance.getZoom();
    if (zoom < 7) return;

    // 3. Get current map bounds
    const bounds = mapInstance.getBounds();

    // 4. Filter visible stations (Limit to max 250 to prevent freezing)
    let count = 0;
    const maxLabels = 250;

    for (const station of currentStationsData) {
        if (count >= maxLabels) break;

        // Basic coordinate check
        if (station.latitude === null || station.longitude === null) continue;

        // Check if inside viewport
        const latLng = L.latLng(station.latitude, station.longitude);
        if (bounds.contains(latLng)) {

            // Determine label color based on category
            let cat = station.metar ? station.metar.category : 'NODATA';
            const labelClass = `map-icao-label label-${cat.toLowerCase()}`;

            // Create lightweight DivIcon
            const labelIcon = L.divIcon({
                className: labelClass,
                html: station.id,
                iconSize: [40, 14],
                // Offset calculation:
                // Anchor [20, -5] places the top of the text 5px BELOW the lat/lon point.
                // This ensures it usually sits just under the center dot.
                iconAnchor: [20, -5] 
            });

            L.marker(latLng, {
                icon: labelIcon,
                interactive: false, // Labels don't need clicks, dots/runways handle that
                // CRITICAL FIX: High Z-Index ensures it floats ABOVE the Arrow (5000) and Runways
                zIndexOffset: 10000  
            }).addTo(labelLayerGroup);

            count++;
        }
    }
}
    // --- GREAT CIRCLE MATH ---
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    function getGreatCircleRoute(lat1, lon1, lat2, lon2, steps = 100) {
    // Haversine/Spherical interpolation for curvature
    const p1 = { lat: toRad(lat1), lon: toRad(lon1) };
    const p2 = { lat: toRad(lat2), lon: toRad(lon2) };

    // Calculate total distance (angular)
    const d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((p2.lat - p1.lat) / 2), 2) +
              Math.cos(p1.lat) * Math.cos(p2.lat) * Math.pow(Math.sin((p2.lon - p1.lon) / 2), 2)));

    const points = [];
    
    // Generate raw points
    for (let i = 0; i <= steps; i++) {
        const f = i / steps;
        const A = Math.sin((1 - f) * d) / Math.sin(d);
        const B = Math.sin(f * d) / Math.sin(d);

        const x = A * Math.cos(p1.lat) * Math.cos(p1.lon) + B * Math.cos(p2.lat) * Math.cos(p2.lon);
        const y = A * Math.cos(p1.lat) * Math.sin(p1.lon) + B * Math.cos(p2.lat) * Math.sin(p2.lon);
        const z = A * Math.sin(p1.lat) + B * Math.sin(p2.lat);

        const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
        const lon = Math.atan2(y, x);
        points.push([toDeg(lat), toDeg(lon)]);
    }

    // FIX: Unwrap longitudes for visual continuity across the Date Line
    // Leaflet handles coordinates outside [-180, 180] correctly by wrapping them visually.
    for (let i = 1; i < points.length; i++) {
        let prevLon = points[i-1][1];
        let currLon = points[i][1];
        let diff = currLon - prevLon;

        // If the jump is too large, shift the current longitude by 360 to smooth it out
        if (diff < -180) {
            currLon += 360;
        } else if (diff > 180) {
            currLon -= 360;
        }
        
        points[i][1] = currLon;
    }

    return points;
}
    function rgbToHex(rgbArray) {
        // Helper to convert your RGB arrays [0, 170, 0] to Hex strings for Leaflet
        return "#" + ((1 << 24) + (rgbArray[0] << 16) + (rgbArray[1] << 8) + rgbArray[2]).toString(16).slice(1);
    }

    // --- MISSING FUNCTION RESTORED ---
    function fetchWithRetry(fn, retries = MAX_RETRIES) {
        return new Promise((resolve, reject) => {
            const attempt = (n) => {
                fn().then(resolve).catch(err => {
                    if (n === 0) return reject(err);
                    setTimeout(() => attempt(n - 1), Math.pow(2, MAX_RETRIES - n) * 1000);
                });
            };
            attempt(retries);
        });
    }

// [UPDATED] Popup Generator with Clickable ICAO and METAR
    function generatePopupContent(station) {
        let metarHtml = '<div class="text-xs italic text-gray-500">No METAR available</div>';
        
        if (station.metar) {
            metarHtml = `<div class="space-y-0.5 pointer-events-none">${formatRawText(station.metar.rawText)}</div>`;
            
            let metaInfo = `${getDisplayTemp(station.metar)} ‚Ä¢ ${station.metar.rh}`;

            // --- Feels Like Logic for Popup ---
            if (station.metar.feelsLike) {
                const valStr = useCelsius ? `${station.metar.feelsLike.c}¬∞` : `${station.metar.feelsLike.f}¬∞`;
                const label = station.metar.feelsLike.label;
                const colorClass = label === 'Wind Chill' ? 'text-cyan-600 dark:text-cyan-400' : 'text-orange-600 dark:text-orange-400';
                
                metaInfo += ` ‚Ä¢ <span class="${colorClass} font-bold">${label} ${valStr}</span>`;
            }
            // ----------------------------------

            if (station.metar.densityAlt) metaInfo += ` ‚Ä¢ ${station.metar.densityAlt}`;
            metaInfo += ` ‚Ä¢ Age: ${formatAge(station.metar.age)}`;
            
            metarHtml += `<div class="mt-1 text-xs text-gray-400 pointer-events-none flex flex-wrap gap-1 items-center">${metaInfo}</div>`;
        }

        let tafHtml = '<div class="text-xs italic text-gray-500">No TAF available</div>';
        if (station.taf) {
            tafHtml = `<div class="space-y-0.5">${formatRawText(station.taf.rawText)}</div>`;
            let notes = [];
            if (station.taf.validTo) notes.push(formatRemainingTime(station.taf.validTo));
            if (station.taf.age !== null) notes.push(`Issued: ${formatAge(station.taf.age)}`);

            if (notes.length > 0) {
                tafHtml += `<div class="mt-2 border-t border-gray-200 dark:border-gray-700 pt-1 flex flex-col gap-0.5">`;
                notes.forEach(n => tafHtml += `<span class="text-xs text-gray-500 dark:text-gray-400 block">${n}</span>`);
                tafHtml += `</div>`;
            }
        }

        return `
            <div class="font-sans">
                <div class="flex items-baseline justify-between mb-2 pb-1 border-b border-gray-200 dark:border-gray-700">
                    <button onclick="openMapDetail('${station.id}')" class="font-bold text-lg text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 transition-colors text-left focus:outline-none">
                        ${station.id}
                        <span class="text-[10px] font-normal text-gray-400 ml-1">‚Üó</span>
                    </button>
                    <span class="text-xs text-gray-500 dark:text-gray-300 ml-2 truncate" style="max-width: 150px;">${station.name || ''}</span>
                </div>

                <div class="mb-2 group cursor-pointer" onclick="openMapDetail('${station.id}')" title="Click for Airport View">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider block">METAR</span>
                        <span class="text-[10px] text-blue-500 opacity-0 group-hover:opacity-100 transition-opacity">View Fullscreen</span>
                    </div>
                    <div class="group-hover:ring-2 group-hover:ring-blue-500/20 group-hover:bg-gray-50 dark:group-hover:bg-gray-800 rounded transition-all p-0.5 -m-0.5">
                        ${metarHtml}
                    </div>
                </div>

                <div class="mb-1">
                    <span class="text-xs font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider block mb-1">TAF</span>
                    ${tafHtml}
                </div>
            </div>
        `;
    }

function renderMap(stations) {
    if (!mapInstance) initMap();

    // 1. Preserve open popups
    let openPopupId = null;
    if (markerLayerGroup.getLayers().length > 0) {
        markerLayerGroup.eachLayer(layer => {
            if (layer.stationId && layer.getPopup() && layer.isPopupOpen()) {
                openPopupId = layer.stationId;
            }
        });
    }

    markerLayerGroup.clearLayers();
    labelLayerGroup.clearLayers();

    // 2. Home Highlight
    const homeInput = document.getElementById('icaoInput').value.trim().toUpperCase();
    if (homeInput.length >= 3 && cachedStationMap && !gpsReferenceCoords) {
        const homeCoords = getCoordsForICAO(homeInput, cachedStationMap);
        if (homeCoords && homeCoords.lat !== null) {
            L.circleMarker([homeCoords.lat, homeCoords.lon], {
                pane: 'routePane', renderer: routeRenderer,
                radius: 12, fill: false, color: '#06b6d4', weight: 3, interactive: false
            }).addTo(markerLayerGroup);
        }
    }

    // 3. Route Drawing
    if (routeAnalysisEnabled) {
        const depInput = document.getElementById('depIcao').value.trim().toUpperCase();
        const destInput = document.getElementById('destIcao').value.trim().toUpperCase();
        
        if (depInput.length >= 3 && destInput.length >= 3 && cachedStationMap) {
           let depCoords = getCoordsForICAO(depInput, cachedStationMap);
           let destCoords = getCoordsForICAO(destInput, cachedStationMap);
           
           if (depCoords && depCoords.lat !== null && destCoords && destCoords.lat !== null) {
               const isSameStation = (Math.abs(depCoords.lat - destCoords.lat) < 0.0001 && Math.abs(depCoords.lon - destCoords.lon) < 0.0001);
               
               if (!isSameStation) {
                   const pathPoints = getGreatCircleRoute(depCoords.lat, depCoords.lon, destCoords.lat, destCoords.lon);
                   
                   L.polyline(pathPoints, { 
                       pane: 'routePane', 
                       renderer: routeRenderer, 
                       color: '#fbbf24', 
                       weight: 2, 
                       opacity: 0.8, 
                       dashArray: '5, 10', 
                       lineCap: 'round', 
                       interactive: false 
                   }).addTo(markerLayerGroup);
               }
               
               L.circleMarker([depCoords.lat, depCoords.lon], { 
                   pane: 'routePane', renderer: routeRenderer, 
                   radius: 12, fill: false, color: '#ffffff', weight: 2, interactive: false 
               }).addTo(markerLayerGroup);
               
               if (!isSameStation) {
                   L.circleMarker([destCoords.lat, destCoords.lon], { 
                       pane: 'routePane', renderer: routeRenderer, 
                       radius: 12, fill: false, color: '#ffffff', weight: 2, interactive: false 
                   }).addTo(markerLayerGroup);
               }
           }
        }
    }

    // 4. Station Rendering
    const bounds = mapInstance.getBounds().pad(0.1); 
    const currentZoom = mapInstance.getZoom();
    const isHighZoom = currentZoom >= 10; 

    stations.forEach(station => {
        if (station.latitude === null || station.longitude === null) return;
        if (!station.metar || !station.metar.category || station.metar.category === 'NODATA') return;
        
        // Culling
        if (!bounds.contains([station.latitude, station.longitude])) return;

        const popupContent = generatePopupContent(station);

        // --- MODE A: REALISTIC RUNWAYS ---
        if (showRunwaysOnMap && isHighZoom && cachedRunwayMap && cachedRunwayMap.has(station.id)) {
            const rwyData = cachedRunwayMap.get(station.id);
            
            // --- UPDATED WIND EXTRACTION LOGIC ---
            // We calculate effectiveSpeed (Max of Gust vs Sustained) to match the dashboard logic
            let windDir = 0, windSpeed = 0, effectiveSpeed = 0;
            
            // 1. Try to extract Gusts from Raw Text using Regex
            const windMatch = station.metar.rawText.match(/(\d{3}|VRB)(\d{2,3})(?:G(\d{2,3}))?KT/);
            
            if (windMatch) {
                windDir = (windMatch[1] === 'VRB') ? 0 : parseInt(windMatch[1]);
                windSpeed = parseInt(windMatch[2]);
                const windGust = windMatch[3] ? parseInt(windMatch[3]) : 0;
                effectiveSpeed = Math.max(windSpeed, windGust);
            } 
            // 2. Fallback to XML parsed values if regex fails
            else if (station.metar.windDir !== null) { 
                windDir = station.metar.windDir; 
                windSpeed = station.metar.windSpeed || 0; 
                effectiveSpeed = windSpeed; // No gust data available here
            }

            // Determine Active Runway using Effective Speed
            const bestIdx = getBestHeadwindRunwayIndex(station.id, windDir, effectiveSpeed);
            
            // Draw Runways (Vectors)
            let sumLat = 0, sumLon = 0, count = 0;
            const drawnKeys = new Set();

            rwyData.runways.forEach((r, idx) => {
                if (!r.leLat || !r.heLat) return;
                const key = [r.leLat, r.leLon, r.heLat, r.heLon].sort().join('-');
                if (drawnKeys.has(key)) return;
                drawnKeys.add(key);

                sumLat += r.leLat + r.heLat; sumLon += r.leLon + r.heLon; count += 2;
                
                const isActive = (idx === bestIdx);
                
                // 1. Casing
                L.polyline([[r.leLat, r.leLon], [r.heLat, r.heLon]], {
                    color: 'white', weight: isActive ? 12 : 8, opacity: 1, 
                    pane: 'markerPane', renderer: markerRenderer, interactive: false, lineCap: 'square'
                }).addTo(markerLayerGroup);

                // 2. Asphalt
                const asphaltLine = L.polyline([[r.leLat, r.leLon], [r.heLat, r.heLon]], {
                    color: '#1e293b', weight: isActive ? 10 : 6, opacity: 1, 
                    pane: 'markerPane', renderer: markerRenderer, interactive: true, lineCap: 'square'
                }).addTo(markerLayerGroup);
                
                asphaltLine.stationId = station.id;
                asphaltLine.bindPopup(popupContent, { autoPan: false });

                // 3. Centerline
                L.polyline([[r.leLat, r.leLon], [r.heLat, r.heLon]], {
                    color: 'white', weight: 1, dashArray: '5, 5', 
                    pane: 'markerPane', renderer: markerRenderer, interactive: false 
                }).addTo(markerLayerGroup);
            });

            // Wind Arrow & Pill
            const centerLat = count > 0 ? sumLat / count : station.latitude;
            const centerLon = count > 0 ? sumLon / count : station.longitude;

            // Use effectiveSpeed for Arrow Color (Red if > 15kts)
            const arrowIcon = L.divIcon({
                className: 'bg-transparent',
                html: `
                <div style="transform: rotate(${windDir}deg); width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; pointer-events: auto; cursor: pointer;">
                    <svg width="60" height="60" viewBox="0 0 100 100" style="width: 100%; height: 100%; overflow: visible; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));">
                        <line x1="50" y1="0" x2="50" y2="100" stroke="${effectiveSpeed > 15 ? '#ef4444' : '#fbbf24'}" stroke-width="8" stroke-linecap="round"/>
                        <path d="M50 100 L70 70 L30 70 Z" fill="${effectiveSpeed > 15 ? '#ef4444' : '#fbbf24'}" stroke="white" stroke-width="2"/>
                    </svg>
                </div>`,
                iconSize: [60, 60],
                iconAnchor: [30, 30]
            });
            
            const arrowMarker = L.marker([centerLat, centerLon], {
                icon: arrowIcon, pane: 'markerPane', interactive: true, zIndexOffset: 5000
            }).addTo(markerLayerGroup);
            
            arrowMarker.stationId = station.id;
            arrowMarker.bindPopup(popupContent, { autoPan: false });

            // --- CROSSWIND PILL (UPDATED) ---
            if (rwyData.runways[bestIdx]) {
                const bestRwy = rwyData.runways[bestIdx];
                const rHeading = bestRwy.heading || 0;
                const diff = Math.abs(windDir - rHeading) % 360;
                const rads = (diff * Math.PI) / 180;
                
                // Use effectiveSpeed (including gusts) for Pill Math
                const hw = Math.round(Math.cos(rads) * effectiveSpeed);
                const xw = Math.round(Math.sin(rads) * effectiveSpeed);

                const pillIcon = L.divIcon({
                    className: 'bg-transparent',
                    html: `<div class="bg-slate-900 border border-indigo-500/50 px-2 py-0.5 rounded-full text-[10px] font-black font-mono text-white shadow-sm whitespace-nowrap flex items-center justify-center">
                            H:${hw} X:${Math.abs(xw)}
                        </div>`,
                    iconSize: [60, 20],
                    iconAnchor: [30, -35] 
                });

                L.marker([centerLat, centerLon], {
                    icon: pillIcon, pane: 'markerPane', interactive: false, zIndexOffset: 6000
                }).addTo(markerLayerGroup);
            }

        } else {
            // --- MODE B: STANDARD DOTS ---
            let cat = station.metar.category;
            const colorRgb = COLORS[cat] || COLORS.NODATA;
            const colorHex = rgbToHex(colorRgb);

            const hitMarker = L.circleMarker([station.latitude, station.longitude], {
                pane: 'markerPane', renderer: markerRenderer,
                radius: 20, stroke: false, fill: true, fillColor: '#fff', fillOpacity: 0.0, interactive: true
            });
            const visualMarker = L.circleMarker([station.latitude, station.longitude], {
                pane: 'markerPane', renderer: markerRenderer,
                radius: 6, fillColor: colorHex, color: '#000', weight: 1, opacity: 0.8, fillOpacity: 0.9, interactive: false
            });

            hitMarker.stationId = station.id;
            hitMarker.bindPopup(popupContent, { autoPan: true });
            
            markerLayerGroup.addLayer(hitMarker);
            markerLayerGroup.addLayer(visualMarker);
        }

        if (openPopupId && station.id === openPopupId) {
            markerLayerGroup.eachLayer(l => {
                if (l.stationId === station.id && typeof l.openPopup === 'function') {
                    setTimeout(() => l.openPopup(), 50);
                }
            });
        }
    });

    updateMapLabels();
}

    // --- EVENT LISTENERS ---
    generateButton.addEventListener('click', (e) => handleGenerateClick(e, false));

    // Updated Event Listener with Loading State
    downloadPdfBtn.addEventListener('click', async () => {
        // Prevent double clicks if already loading
        if (downloadPdfBtn.disabled) return;

        const originalContent = downloadPdfBtn.innerHTML;

        // Set Loading State
        downloadPdfBtn.disabled = true;
        downloadPdfBtn.innerHTML = `
            <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating...
        `;

        // Small timeout to allow UI to render the loading state before the heavy PDF sync work begins
        await new Promise(r => setTimeout(r, 50));

        try {
            if(currentReportData && currentReportData.stationsData.length > 0) {
                generatePDF(currentReportData.stationsData, currentReportData.refName, currentReportData.routeAnalysisResult);
            }
        } catch (e) {
            console.error("PDF Generation failed:", e);
            alert("Failed to generate PDF. Please try again.");
        } finally {
            // Restore Button State
            downloadPdfBtn.innerHTML = originalContent;
            downloadPdfBtn.disabled = false;
        }
    });

    toggleAdvancedButton.addEventListener('click', toggleAdvancedPanel);
    tabStandard.addEventListener('click', () => switchTab('standard'));
    tabMap.addEventListener('click', () => switchTab('map'));
    tabRouteAnalysis.addEventListener('click', () => switchTab('route-analysis'));

    // --- MODAL LOGIC ---
    function handleModalClick(event) {
        if (event.target === modal) closeTileModal();
    }

    function closeTileModal() {
        modal.classList.add('hidden');
        document.body.style.overflow = ''; // Restore scrolling
    }

    // --- FULLSCREEN TOGGLE LOGIC ---
    function toggleMapFullscreen() {
        const mapView = document.getElementById('mapView');
        const fsControls = document.getElementById('fullscreenControls');
        const triggerBtn = document.getElementById('btnEnterFullscreen');

        // Toggle the class on the container
        mapView.classList.toggle('fullscreen-active');
        const isFullscreen = mapView.classList.contains('fullscreen-active');

        if (isFullscreen) {
            // Entered Fullscreen
            fsControls.classList.remove('hidden'); // Show floating island controls
            //triggerBtn.classList.add('hidden');    // Hide the small toggle button
            document.body.classList.add('map-mode'); // Prevent background scrolling
            requestWakeLock(); // Prevent screen sleep
        } else {
            // Exited Fullscreen (Back to Embedded)
            fsControls.classList.add('hidden');
            triggerBtn.classList.remove('hidden');
            document.body.classList.remove('map-mode');
            releaseWakeLock(); // Allow screen sleep
        }

        // Re-render Leaflet size
        setTimeout(() => {
            if (mapInstance) mapInstance.invalidateSize();
        }, 200);
    }

    // --- PERSISTENCE & AUTO-FILL ---
    let isMirroringHome = false;

    function loadSavedInputs() {
        try {
            const savedHome = localStorage.getItem('homeIcao');
            const savedDep = localStorage.getItem('depIcao');
            const savedDest = localStorage.getItem('destIcao');
            const savedRadius = localStorage.getItem('searchRadius');
            const savedRunway = localStorage.getItem('minRunway');

            // Skip if it was "GPS LOC", force default or blank
            if (savedHome && savedHome !== "GPS LOC") {
                icaoInput.value = savedHome;
            }
            if (savedDep) depIcaoInput.value = savedDep;
            if (savedDest) destIcaoInput.value = savedDest;
            if (savedRadius) searchRadiusInput.value = savedRadius;
            if (savedRunway) minRunwayInput.value = savedRunway;
        } catch(e) {}
    }

    icaoInput.addEventListener('input', () => {
        icaoInput.value = icaoInput.value.toUpperCase();
        isMirroringHome = false;
        try { localStorage.setItem('homeIcao', icaoInput.value); } catch(e){}
    });

    depIcaoInput.addEventListener('input', () => {
        depIcaoInput.value = depIcaoInput.value.toUpperCase();
        const val = depIcaoInput.value;
        try {
            localStorage.setItem('depIcao', val);
            if (!icaoInput.value.trim()) isMirroringHome = true;
            if (isMirroringHome) {
                icaoInput.value = val;
                localStorage.setItem('homeIcao', val);
            }
        } catch(e){}
    });

    destIcaoInput.addEventListener('input', () => {
        destIcaoInput.value = destIcaoInput.value.toUpperCase();
        try { localStorage.setItem('destIcao', destIcaoInput.value); } catch(e){}
    });

    searchRadiusInput.addEventListener('change', () => {
        try { localStorage.setItem('searchRadius', searchRadiusInput.value); } catch(e){}
    });

    minRunwayInput.addEventListener('change', () => {
        try { localStorage.setItem('minRunway', minRunwayInput.value); } catch(e){}
    });

    loadSavedInputs();

    // Auto-generate on load (Requirement: show map on startup)
    if (!icaoInput.value.trim()) {
        icaoInput.value = "KOKC"; // Default if nothing saved
    }
    // Small delay to ensure DOM is ready and UI updates don't clash
    setTimeout(() => {
        handleGenerateClick(null, true);
    }, 100);

function toggleAdvancedPanel() {
        const isHidden = advancedInputsEl.classList.contains('hidden');
        if (isHidden) {
            // ENABLE MODE
            advancedInputsEl.classList.remove('hidden');

            // Change Button Style to "Ghost/Outline" to signify Disable
            toggleAdvancedButton.textContent = 'Disable Alternate Planning';
            // Remove the solid yellow
            toggleAdvancedButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-white');
            // Add the outline style
            toggleAdvancedButton.classList.add('bg-transparent', 'border-2', 'border-yellow-500', 'text-yellow-600', 'hover:bg-yellow-50', 'dark:text-yellow-400', 'dark:hover:bg-gray-900');

            routeAnalysisEnabled = true;
            nodataLegendEl.style.display = 'flex';
        } else {
            // DISABLE MODE
            advancedInputsEl.classList.add('hidden');

            // Change Button Style back to Solid Yellow
            toggleAdvancedButton.textContent = 'Enable Alternate Planning';
            // Remove outline style
            toggleAdvancedButton.classList.remove('bg-transparent', 'border-2', 'border-yellow-500', 'text-yellow-600', 'hover:bg-yellow-50', 'dark:text-yellow-400', 'dark:hover:bg-gray-900');
            // Add solid yellow
            toggleAdvancedButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'text-white');

            routeAnalysisEnabled = false;
            tabRouteAnalysis.classList.add('hidden');
            nodataLegendEl.style.display = 'none';
        }

        // FORCE MAP UPDATE: Redraw map immediately to show/hide the route line
        if (currentStationsData.length > 0 && mapInstance) {
            renderMap(currentStationsData);
        }
    }

    const TAB_ACTIVE_CLASSES = ['bg-blue-600', 'text-white', 'shadow'];
    const TAB_INACTIVE_CLASSES = ['text-gray-700', 'dark:text-gray-400', 'hover:bg-gray-300', 'dark:hover:bg-gray-800'];
// --- DOM ELEMENTS TO MANIPULATE ---
const containerEl = document.getElementById('resultsContainer');
const scrollBoxEl = containerEl.querySelector('.flex-grow.overflow-y-auto'); 

async function openDashboard() {
    // 1. Activate Dashboard Mode
    document.body.classList.add('dashboard-active-mode');

    // 2. BREAK THE BOX
    containerEl.classList.remove('h-[85vh]', 'md:max-h-[85vh]', 'overflow-y-auto');
    containerEl.classList.add('h-auto', 'min-h-screen', 'overflow-visible');

    // 3. REMOVE INNER SCROLLBAR
    if (scrollBoxEl) {
        scrollBoxEl.classList.remove('overflow-y-auto', 'h-full', 'flex-grow');
        scrollBoxEl.classList.add('h-auto', 'overflow-visible');
    }

    // 4. Hide other tabs
    document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
    
    // 5. Show Dashboard
    document.getElementById('customDashboardView').classList.remove('hidden');
    containerEl.classList.remove('hidden');

    // 6. Reset Tab Buttons
    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove(...TAB_ACTIVE_CLASSES);
        btn.classList.add(...TAB_INACTIVE_CLASSES);
    });

    // --- NEW: INITIALIZE DRAG & DROP ---
    const grid = document.getElementById('dashboardGrid');
    if (window.Sortable && !grid._sortable) {
        grid._sortable = new Sortable(grid, {
            animation: 200,
            delay: 200,            // 200ms press and hold required
            delayOnTouchOnly: true, // Immediate drag on mouse, hold on touch
            touchStartThreshold: 3, // Prevents accidental drag when scrolling
            ghostClass: 'opacity-50', 
            onEnd: function (evt) {
                // Update Data State to match new visual order
                const item = dashboardState.stations.splice(evt.oldIndex, 1)[0];
                dashboardState.stations.splice(evt.newIndex, 0, item);
                saveDashboardState();
            }
        });
    }

    // 7. Loading State for Runways
    if (!cachedRunwayMap || cachedRunwayMap.size === 0) {
        grid.innerHTML = `
            <div class="col-span-full flex flex-col items-center justify-center p-12 opacity-50">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-indigo-600 border-r-transparent"></div>
                <p class="mt-4 text-xs font-bold font-mono">DOWNLOADING DATA...</p>
            </div>
        `;
        try { await getRunwayData(); } catch(e) { console.error(e); }
    }

    renderDashboard();

    // 8. Scroll to top
    setTimeout(() => {
        window.scrollTo({ top: containerEl.offsetTop - 20, behavior: 'smooth' });
    }, 100);
}


function exitDashboard() {
    document.body.classList.remove('dashboard-active-mode');

    // 1. RESTORE THE BOX: Put back the fixed height constraints for the Map/List views
    containerEl.classList.add('h-[85vh]', 'md:max-h-[85vh]'); 
    containerEl.classList.remove('h-auto', 'min-h-screen', 'overflow-visible');

    // 2. RESTORE INNER SCROLLBAR:
    if (scrollBoxEl) {
        scrollBoxEl.classList.add('overflow-y-auto', 'h-full', 'flex-grow');
        scrollBoxEl.classList.remove('h-auto', 'overflow-visible');
    }

    // Default back to Map
    switchTab('map');
}

function switchTab(tabId) {
    // Safety: If we click a tab button while in Dashboard mode, force exit first
    if (document.body.classList.contains('dashboard-active-mode') && tabId !== 'dashboard') {
        exitDashboard(); // This handles the class restoration
        // exitDashboard calls switchTab('map') at the end, so we might need to override if the user clicked 'standard'
        // But for simplicity, let's just let it fall through.
    }

    const contents = document.querySelectorAll('.tab-content');
    const buttons = document.querySelectorAll('.tab-button');
    const mapView = document.getElementById('mapView');

    // Force exit fullscreen if switching tabs away from map
    if (mapView.classList.contains('fullscreen-active')) {
        toggleMapFullscreen();
    }

    // Hide all contents
    contents.forEach(el => el.classList.add('hidden'));

    // Reset all buttons
    buttons.forEach(btn => {
        btn.classList.remove(...TAB_ACTIVE_CLASSES);
        btn.classList.add(...TAB_INACTIVE_CLASSES);
    });

    if (tabId === 'standard') {
        weatherListEl.classList.remove('hidden');
        tabStandard.classList.remove(...TAB_INACTIVE_CLASSES);
        tabStandard.classList.add(...TAB_ACTIVE_CLASSES);

        if (weatherListEl.children.length === 0 && currentReportData.stationsData.length > 0) {
             renderInBrowser(currentReportData.stationsData, currentReportData.refName, null);
        }
        fillListContainer();
    }
    else if (tabId === 'map') {
        document.getElementById('mapView').classList.remove('hidden');
        tabMap.classList.remove(...TAB_INACTIVE_CLASSES);
        tabMap.classList.add(...TAB_ACTIVE_CLASSES);

        if (mapInstance) {
            setTimeout(() => {
                mapInstance.invalidateSize();
                if (currentStationsData.length > 0) renderMap(currentStationsData);
            }, 100);
        }
    }
    else if (tabId === 'route-analysis') {
        routeAnalysisViewEl.classList.remove('hidden');
        tabRouteAnalysis.classList.remove(...TAB_INACTIVE_CLASSES);
        tabRouteAnalysis.classList.add(...TAB_ACTIVE_CLASSES);
    }
}


// --- DASHBOARD SEARCH & CLEAR LOGIC ---

function clearDashboard() {
    // Check if empty first
    if (dashboardState.stations.length === 0) return;
    
    // Update the text count in the modal dynamically (optional polish)
    const modalBody = document.querySelector('#confirmClearModal p');
    if(modalBody) {
        modalBody.innerHTML = `This will remove all <b>${dashboardState.stations.length}</b> tiles. This action cannot be undone.`;
    }

    // Show custom modal (bypasses browser popup blockers)
    document.getElementById('confirmClearModal').classList.remove('hidden');
}

function closeClearModal() {
    document.getElementById('confirmClearModal').classList.add('hidden');
}

function confirmClearAction() {
    dashboardState.stations = [];
    dashboardState.selectedRunways = {};
    saveDashboardState();
    renderDashboard();
    closeClearModal();
}

function openDashSearchModal() {
    const modal = document.getElementById('dashboardSearchModal');
    const input = document.getElementById('advSearchCenter');
    const status = document.getElementById('advSearchStatus');
    
    // Auto-fill with current ICAO input if available
    const mainInput = document.getElementById('icaoInput');
    if(mainInput && mainInput.value && mainInput.value !== '-GPS-') {
        input.value = mainInput.value;
    }
    
    status.textContent = "";
    modal.classList.remove('hidden');
    input.focus();
}

function closeDashSearchModal() {
    document.getElementById('dashboardSearchModal').classList.add('hidden');
}

async function performAdvancedDashSearch() {
    const centerIcao = document.getElementById('advSearchCenter').value.trim().toUpperCase();
    const radiusStr = document.getElementById('advSearchRadius').value;
    const minRwyStr = document.getElementById('advSearchRwy').value;
    
    const radius = parseInt(radiusStr) || 50;
    const minRwy = parseInt(minRwyStr) || 0;
    const status = document.getElementById('advSearchStatus');

    if (centerIcao.length < 3) {
        status.textContent = "Please enter a valid Center ICAO.";
        status.className = "text-xs text-center font-bold text-red-500";
        return;
    }

    status.textContent = "Loading database...";
    status.className = "text-xs text-center font-bold text-blue-500 animate-pulse";

    try {
        if (!cachedStationMap) await getStationMap();
        if (!cachedRunwayMap) await getRunwayData();

        let sourceList = allStationsData;
        if (!sourceList || sourceList.length === 0) {
            sourceList = Array.from(cachedStationMap.entries()).map(([id, data]) => ({
                id: id,
                latitude: data.latitude,
                longitude: data.longitude
            }));
        }

        const centerCoords = getCoordsForICAO(centerIcao, cachedStationMap);
        
        if (!centerCoords || centerCoords.lat === null) {
            status.textContent = `Airport ${centerIcao} not found.`;
            status.className = "text-xs text-center font-bold text-red-500";
            return;
        }

        status.textContent = "Searching & Sorting...";
        
        // 1. Collect Candidates
        let candidates = [];

        for (const station of sourceList) {
            if (station.latitude === null || station.longitude === null) continue;

            const dist = haversineDistance(centerCoords.lat, centerCoords.lon, station.latitude, station.longitude);
            
            if (dist <= radius) {
                if (dashboardState.stations.includes(station.id)) continue;

                let validRunway = true;
                if (minRwy > 0) {
                     const rwyEntry = cachedRunwayMap.get(station.id);
                     if (!rwyEntry || rwyEntry.maxLen < minRwy) validRunway = false;
                }

                if (validRunway) {
                    candidates.push({ id: station.id, distance: dist });
                }
            }
        }

        // 2. Sort by Distance
        candidates.sort((a, b) => a.distance - b.distance);

        // 3. Add to Dashboard (Limit increased to 500)
        let addedCount = 0;
        const maxToAdd = 500; // <--- INCREASED LIMIT

        for (const cand of candidates) {
            if (addedCount >= maxToAdd) break;
            dashboardState.stations.push(cand.id);
            addedCount++;
        }

        saveDashboardState();
        renderDashboard(); 
        
        closeDashSearchModal();
        
      
    } catch (e) {
        console.error(e);
        status.textContent = "Error searching database.";
        status.className = "text-xs text-center font-bold text-red-500";
    }
}
  
    async function checkForUpdates() {
        try {
            const response = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/releases/latest`);
            if (!response.ok) return;
            const data = await response.json();
            const latestVersion = data.tag_name;
            if (isNewerVersion(CURRENT_VERSION, latestVersion)) {
                showUpdateBanner(latestVersion, data);
            }
        } catch (error) {}
    }

    function isNewerVersion(current, latest) {
        const cleanCurrent = current.replace(/^v/, '');
        const cleanLatest = latest.replace(/^v/, '');
        const currentParts = cleanCurrent.split('.').map(Number);
        const latestParts = cleanLatest.split('.').map(Number);
        for (let i = 0; i < Math.max(currentParts.length, latestParts.length); i++) {
            const curr = currentParts[i] || 0;
            const lat = latestParts[i] || 0;
            if (lat > curr) return true;
            if (lat < curr) return false;
        }
        return false;
    }

    function showUpdateBanner(version, releaseData) {
        const banner = document.getElementById('updateBanner');
        const versionSpan = document.getElementById('newVersionTag');
        const downloadBtn = document.getElementById('downloadUpdateBtn');
        const closeBtn = document.getElementById('closeUpdateBanner');

        versionSpan.textContent = version;

        // 1. Try to get direct APK asset link
        let downloadUrl = null;
        if (releaseData.assets) {
            const apkAsset = releaseData.assets.find(asset => asset.name.toLowerCase().endsWith('.apk'));
            if (apkAsset) downloadUrl = apkAsset.browser_download_url;
        }

        // 2. Fallback to standard "Latest" URL if asset parsing failed
        // This is robust because GitHub handles the redirect
        if (!downloadUrl) {
            downloadUrl = `https://github.com/${GITHUB_REPO}/releases/latest/download/app-release.apk`;
        }

        // Setup Button
        downloadBtn.href = "#"; // Controlled by JS

        downloadBtn.onclick = (e) => {
            e.preventDefault();

            // A. Try Android Bridge
            if (window.Android && typeof window.Android.launchUpdate === 'function') {
                try {
                    window.Android.launchUpdate(downloadUrl);
                    return;
                } catch (err) {
                    console.error("Bridge update failed", err);
                }
            }

            // B. Force Navigation (Works better than window.open in WebViews)
            window.location.href = downloadUrl;
        };

        banner.classList.remove('hidden');
        banner.classList.add('update-banner-enter');

        closeBtn.onclick = () => banner.classList.add('hidden');
    }
    checkForUpdates();

    function showStatus(message, isError = false, details = "") {
        resultsContainerEl.classList.add('hidden');
        statusEl.textContent = message;
        statusEl.className = 'mt-6 p-4 text-center rounded-lg';
        if (isError) {
            statusEl.classList.add('bg-red-100', 'dark:bg-red-900', 'text-red-700', 'dark:text-red-200');
        } else {
            statusEl.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-200');
        }
        statusEl.style.display = 'block';
        detailsEl.textContent = details || '';
        detailsEl.style.display = details ? 'block' : 'none';
    }

    function showSuccess(message) {
        // Disabled persistent success message as requested.
        // Status element is hidden to clear UI space.
        statusEl.style.display = 'none';
        detailsEl.style.display = 'none';
    }
    
async function fetchAndDrawTrace(hex) {
    // 1. Handle switching planes (Clear old path if clicking a new plane)
    if (selectedAircraftHex && selectedAircraftHex !== hex) {
        clearFlightPath();
    }
    selectedAircraftHex = hex;

    try {
        const lastTwo = hex.slice(-2);
        const targetUrl = `https://globe.airplanes.live/data/traces/${lastTwo}/trace_full_${hex.toLowerCase()}.json`;
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
        
        const res = await fetch(proxyUrl);
        if (!res.ok) return;
        
        const data = await res.json();
        if (!data.trace || data.trace.length === 0) return;

        const trace = data.trace;
        let startIndex = 0;

        // --- FILTER LEG LOGIC ---
        const isGround = (p) => p[3] === "ground" || (typeof p[3] === 'number' && p[4] < 50 && p[3] < 500);
        const lastPoint = trace[trace.length - 1];
        let currentlyInAir = !isGround(lastPoint);

        for (let i = trace.length - 1; i >= 0; i--) {
            const point = trace[i];
            const onGround = isGround(point);
            if (i > 0 && (point[0] - trace[i-1][0] > 1800)) { startIndex = i; break; }

            if (currentlyInAir) {
                if (onGround) { startIndex = i; break; }
            } else {
                if (!onGround) currentlyInAir = true;
            }
        }

        // 2. Get Historical Points
        const latLngs = trace.slice(startIndex)
            .map(point => [point[1], point[2]])
            .filter(pt => pt[0] !== null && pt[1] !== null);

        if (!mapInstance) return;

        // 3. Draw or Update History (Solid Line)
        if (selectedPlaneTrace) {
            // Update existing line (Smooth)
            selectedPlaneTrace.setLatLngs(latLngs);
        } else {
            // Create new line
            selectedPlaneTrace = L.polyline(latLngs, {
                color: '#10b981', 
                weight: 3,
                opacity: 0.8,
                dashArray: '5, 5', 
                lineCap: 'round',
                pane: 'trafficPane', 
                interactive: false
            }).addTo(mapInstance);
        }

        // 4. Draw or Update Estimated Segment
        if (trafficMarkers.has(hex) && latLngs.length > 0) {
            const lastHistPos = latLngs[latLngs.length - 1];
            const currentLivePos = trafficMarkers.get(hex).getLatLng();
            const estPoints = [lastHistPos, currentLivePos];

            if (selectedPlaneTraceEst) {
                selectedPlaneTraceEst.setLatLngs(estPoints);
            } else {
                selectedPlaneTraceEst = L.polyline(estPoints, {
                    color: '#6ee7b7', 
                    weight: 2,        
                    opacity: 0.6,
                    dashArray: '2, 6', 
                    pane: 'trafficPane',
                    interactive: false
                }).addTo(mapInstance);
            }
        } else if (selectedPlaneTraceEst) {
            // If marker is gone or no history, remove the estimate line
            mapInstance.removeLayer(selectedPlaneTraceEst);
            selectedPlaneTraceEst = null;
        }

    } catch (e) {
        // Silent fail
    }
}

  
function clearFlightPath() {
    // Stop tracking the ID
    selectedAircraftHex = null;

    if (selectedPlaneTrace && mapInstance) {
        mapInstance.removeLayer(selectedPlaneTrace);
        selectedPlaneTrace = null;
    }
    if (selectedPlaneTraceEst && mapInstance) {
        mapInstance.removeLayer(selectedPlaneTraceEst);
        selectedPlaneTraceEst = null;
    }
}

    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const toRad = (deg) => deg * (Math.PI / 180);
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return (R * c) * 0.539957;
    }

    function calculateAgeInMinutes(isoTimestamp) {
        try {
            const timestamp = new Date(isoTimestamp);
            const now = new Date();
            const diffMs = now.getTime() - timestamp.getTime();
            return Math.floor(diffMs / (1000 * 60));
        } catch (e) {
            return null;
        }
    }

    function formatAge(minutes) {
        if (minutes === null || isNaN(minutes)) return "N/A";
        if (minutes < 60) return `${minutes} min ago`;
        if (minutes < 1440) {
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m ago` : `${hours} hours ago`;
        }
        const days = Math.floor(minutes / 1440);
        return `${days} days ago`;
    }

    function getCategoryColor(cat) {
        if (!cat) return COLORS.VFR;
        const c = cat.toUpperCase().trim();
        return COLORS[c] || COLORS.VFR;
    }

    function getCategoryClassName(cat) {
        if (!cat) return 'vfr-dot';
        const c = cat.toUpperCase().trim();
        const map = { 'LIFR': 'lifr-dot', 'IFR': 'ifr-dot', 'MVFR': 'mvfr-dot', 'NODATA': 'nodata-tile' };
        return map[c] || 'vfr-dot';
    }

    function getCategoryTileClassName(cat) {
        if (!cat) return 'vfr-tile';
        const c = cat.toUpperCase().trim();
        const map = { 'LIFR': 'lifr-tile', 'IFR': 'ifr-tile', 'MVFR': 'mvfr-tile', 'NODATA': 'nodata-tile' };
        return map[c] || 'vfr-tile';
    }

    function getCategoryPriority(cat) {
        if (!cat) return CATEGORY_ORDER.VFR;
        const c = cat.toUpperCase().trim();
        return CATEGORY_ORDER[c] || CATEGORY_ORDER.VFR;
    }

function calculateTempFAndRH(metarNode) {
        const tempC = parseFloat(metarNode.querySelector("temp_c")?.textContent);
        const dewpointC = parseFloat(metarNode.querySelector("dewpoint_c")?.textContent);

        if (isNaN(tempC) || isNaN(dewpointC)) return { tempF: "N/A", tempC: "N/A", rh: "N/A", rawDewC: null, rawRh: null };

        const tempF = Math.round(tempC * 9/5 + 32);
        const satVP = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
        const actVP = 6.112 * Math.exp((17.67 * dewpointC) / (dewpointC + 243.5));
        const rh = Math.round(actVP / satVP * 100);

        return {
            tempF: `${tempF}¬∞F`,
            tempC: `${Math.round(tempC)}¬∞C`,
            rh: `RH ${rh}%`,
            rawDewC: dewpointC,
            rawRh: rh // <--- ADD THIS LINE
        };
    }
    
    function cleanRawText(text) {
        if (!text) return "";
        // Remove 'AMD 1234' or 'COR 5678' so they aren't read as visibility
        let clean = text.replace(/\b(AMD|COR|CNL)\s+\d{4}\b/g, ' ');
        return clean;
    }

    function analyzeCondition(text) {
        if (!text) return 'VFR';
        let cleanText = cleanRawText(text);

        // Normalize VV tokens
        cleanText = cleanText.replace(/\bVV(\d{1,3})\b/, function(m, g) { return 'VV' + g.padStart(3, '0'); });

        const suf = '(?:TCU|CB)?';
        const isLIFR_Ceil = new RegExp(`(BKN|OVC|VV)00[0-4]${suf}\\b`).test(cleanText);
        const isIFR_Ceil = new RegExp(`(BKN|OVC|VV)00[5-9]${suf}\\b`).test(cleanText);
        const isMVFR_Ceil = new RegExp(`(BKN|OVC|VV)(0[1-2]\\d|030)${suf}\\b`).test(cleanText);

        const isLIFR_SM = /\b(M)?(0|1)\/\dSM\b|\b0SM\b|\b(M)?0SM\b|\b(M)?1\/[248]SM\b/.test(cleanText);
        const isLIFR_M = /(?:^|\s)(0\d{3}|1[0-5]\d{2})(?=\s|$)/.test(cleanText);

        const isIFR_SM = /\b[1-2]( \d\/\d)?SM\b|\b1SM\b|\b2SM\b/.test(cleanText);
        const isIFR_M = /(?:^|\s)(1[6-9]\d{2}|[2-4]\d{3})(?=\s|$)/.test(cleanText);

        const isMVFR_SM = /\b[3-5]SM\b/.test(cleanText);
        const isMVFR_M = /(?:^|\s)([5-7]\d{3}|8000)(?=\s|$)/.test(cleanText);

        if (isLIFR_Ceil || isLIFR_SM || isLIFR_M) return 'LIFR';
        if (isIFR_Ceil || isIFR_SM || isIFR_M) return 'IFR';
        if (isMVFR_Ceil || isMVFR_SM || isMVFR_M) return 'MVFR';
        return 'VFR';
    }


    async function fetchAndParse(url) {
        // DIRECT LOCAL FETCH - NO PROXY
        const cacheBuster = (url.includes('?') ? '&' : '?') + 'cb=' + Date.now();
        const fetchUrl = url + cacheBuster;

        return fetchWithRetry(async () => {
            const response = await fetch(fetchUrl, {
                cache: "no-store"
            });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const buffer = await response.arrayBuffer();
            if (buffer.byteLength === 0) throw new Error("Empty file");
            
            const view = new Uint8Array(buffer);
            let xmlText = "";
            // Check for GZip signature (1f 8b)
            if (view[0] === 0x1f && view[1] === 0x8b) {
                const decompressed = pako.inflate(view);
                xmlText = new TextDecoder("utf-8").decode(decompressed);
            } else {
                xmlText = new TextDecoder("utf-8").decode(view);
            }

            if (!xmlText.trim()) throw new Error("Decompressed empty");
            const xmlDoc = new DOMParser().parseFromString(xmlText, "application/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error("XML parse error");
            return xmlDoc;
        });
    }
    async function getStationMap() {
        if (cachedStationMap) return cachedStationMap;
        try {
            const stationsDoc = await fetchAndParse(STATIONS_DATA_URL);
            const map = new Map();
            stationsDoc.querySelectorAll("Station").forEach(node => {
                const id = node.querySelector("station_id")?.textContent?.trim();
                const site = node.querySelector("site")?.textContent?.trim();
                const state = node.querySelector("state")?.textContent?.trim();
                const country = node.querySelector("country")?.textContent?.trim();
                const lat = parseFloat(node.querySelector("latitude")?.textContent);
                const lon = parseFloat(node.querySelector("longitude")?.textContent);

                // --- NEW: Parse Elevation ---
                const elevM = parseFloat(node.querySelector("elevation_m")?.textContent);
                const elevFt = isNaN(elevM) ? null : Math.round(elevM * 3.28084);
                // ----------------------------

                if (id && site) {
                    const cleanSite = site.replace(/\/INTL$/, '').replace(/\//g, ' ');
                    let label = cleanSite;
                    if (country === 'US' && state) label += `, ${state}`;
                    else if (country) label += `, ${country}`;
                    else if (state) label += `, ${state}`;

                    // Store elevationFt in the map
                    map.set(id, { name: label, latitude: isNaN(lat) ? null : lat, longitude: isNaN(lon) ? null : lon, elevationFt: elevFt });
                }
            });
            cachedStationMap = map;
            return map;
        } catch (e) {
            console.warn("Failed to fetch station DB, proceeding without names/coords", e);
            return new Map();
        }
    }

   async function getRunwayData() {
    if (cachedRunwayMap) return cachedRunwayMap;

    const response = await fetch(RUNWAY_DATA_URL);
    if (!response.ok) throw new Error("Failed to download runway database");

    const text = await response.text();
    const map = new Map();
    const lines = text.split('\n');

    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const parts = line.match(/(?:^|,)("(?:[^"]|"")*"|[^,]*)/g);
        if (!parts || parts.length < 17) continue;

        const clean = (val) => val ? val.replace(/^,/, '').replace(/^"|"$/g, '').trim() : '';

        const ident = clean(parts[2]).toUpperCase();
        const lenStr = clean(parts[3]);
        const len = parseInt(lenStr);
        
        const leIdent = clean(parts[8]); 
        const leLat = parseFloat(clean(parts[9]));
        const leLon = parseFloat(clean(parts[10]));
        const leHeadingRaw = parts.length > 12 ? clean(parts[12]) : '';
        
        const heIdent = parts.length > 14 ? clean(parts[14]) : null;
        const heLat = parseFloat(clean(parts[15]));
        const heLon = parseFloat(clean(parts[16]));
        const heHeadingRaw = parts.length > 18 ? clean(parts[18]) : '';

        if (ident && !isNaN(len) && len > 0 && !isNaN(leLat) && !isNaN(leLon) && !isNaN(heLat) && !isNaN(heLon)) {
            if (!map.has(ident)) map.set(ident, { maxLen: 0, runways: [] });
            
            const entry = map.get(ident);
            if (len > entry.maxLen) entry.maxLen = len;

            let h1 = parseFloat(leHeadingRaw);
            let h2 = parseFloat(heHeadingRaw);
            
            if (isNaN(h1)) h1 = calculateBearing(leLat, leLon, heLat, heLon);
            if (isNaN(h2)) h2 = (h1 + 180) % 360;

            // Push Low End (e.g. 09)
            entry.runways.push({
                id: leIdent, oppId: heIdent, length: len, heading: h1,
                leLat: leLat, leLon: leLon, heLat: heLat, heLon: heLon
            });

            // Push High End (e.g. 27)
            if (heIdent) {
                entry.runways.push({
                    id: heIdent, oppId: leIdent, length: len, heading: h2,
                    leLat: heLat, leLon: heLon, heLat: leLat, heLon: leLon
                });
            }
        }
    }
    cachedRunwayMap = map;
    return map;
}


// Helper to calculate bearing between two points
function calculateBearing(lat1, lon1, lat2, lon2) {
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;
    const dLon = toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(toRad(lat2));
    const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
              Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
    let brng = toDeg(Math.atan2(y, x));
    return (brng + 360) % 360;
}

    function getCoordsForICAO(icao, stationMap) {
        const data = stationMap.get(icao.toUpperCase());
        return data ? { lat: data.latitude, lon: data.longitude } : null;
    }

    function resolveTafDate(issueDate, day, hour) {
        const date = new Date(issueDate);
        date.setUTCDate(day);
        date.setUTCHours(hour);
        date.setUTCMinutes(0);
        date.setUTCSeconds(0);
        if (day < issueDate.getUTCDate() - 5) date.setUTCMonth(date.getUTCMonth() + 1);
        else if (day > issueDate.getUTCDate() + 5) date.setUTCMonth(date.getUTCMonth() - 1);
        return date;
    }

    // --- REVISED TAF PARSING LOGIC & STATE MANAGEMENT ---


    function parseTafToBlocks(tafRawText, issueTime) {
        const rawTokens = tafRawText.split(/\s(?=(?:FM\d{6}|BECMG|TEMPO|PROB\d{2}))/);
        const tokens = [];
        for (let i = 0; i < rawTokens.length; i++) {
            const t = rawTokens[i].trim();
            if (/^PROB\d{2}$/.test(t) && rawTokens[i+1] && rawTokens[i+1].trim().startsWith('TEMPO')) {
                tokens.push(t + ' ' + rawTokens[i+1].trim());
                i++;
            } else {
                tokens.push(t);
            }
        }

        let parsedBlocks = [];
        let baseStart = issueTime.getTime();

        tokens.forEach(token => {
            const cleanToken = token.trim();
            if(!cleanToken) return;

            let type = 'BASE';
            let start = baseStart;
            let end = null;
            let visualEnd = null;

            if (cleanToken.startsWith('FM')) {
                type = 'BASE';
                const d = parseInt(cleanToken.substring(2, 4));
                const h = parseInt(cleanToken.substring(4, 6));
                const m = parseInt(cleanToken.substring(6, 8));
                const fmDate = resolveTafDate(issueTime, d, h);
                fmDate.setUTCMinutes(m);
                start = fmDate.getTime();
                baseStart = start;
            }
            else if (cleanToken.startsWith('BECMG')) {
                type = 'CHANGE';
                const timeMatch = cleanToken.match(/(\d{2})(\d{2})\/(\d{2})(\d{2})/);
                if (timeMatch) {
                    const [_, sd, sh, ed, eh] = timeMatch;
                    start = resolveTafDate(issueTime, parseInt(sd), parseInt(sh)).getTime();
                    end = resolveTafDate(issueTime, parseInt(ed), parseInt(eh)).getTime();
                } else {
                    start = baseStart;
                }
            }
            else if (/^(TEMPO|PROB)/.test(cleanToken)) {
                type = 'TEMP';
                const timeMatch = cleanToken.match(/(\d{2})(\d{2})\/(\d{2})(\d{2})/);
                if (timeMatch) {
                    const [_, sd, sh, ed, eh] = timeMatch;
                    start = resolveTafDate(issueTime, parseInt(sd), parseInt(sh)).getTime();
                    end = resolveTafDate(issueTime, parseInt(ed), parseInt(eh)).getTime();
                } else {
                    start = baseStart;
                    end = baseStart + (1 * 60 * 60 * 1000);
                }
                visualEnd = end;
            }
            else {
                // Initial block
                type = 'BASE';
                start = issueTime.getTime();
            }

            // Temporary object, visualEnd for BASE/CHANGE calculated after sorting
            parsedBlocks.push({ type, start, end, visualEnd, text: cleanToken });
        });

        // Calculate visualEnd for prevailing blocks (BASE and CHANGE)
        // They act as the "active" line until the next prevailing block starts.
        const prevailingBlocks = parsedBlocks.filter(b => b.type === 'BASE' || b.type === 'CHANGE');
        prevailingBlocks.sort((a, b) => a.start - b.start);

        for(let i = 0; i < prevailingBlocks.length; i++) {
            if (i < prevailingBlocks.length - 1) {
                prevailingBlocks[i].visualEnd = prevailingBlocks[i+1].start;
            } else {
                prevailingBlocks[i].visualEnd = 4102444800000; // Infinity
            }
            // Sync this back to the main list (passed by reference inside object)
        }

        return parsedBlocks;
    }

function getWorstFlightCategoryFromTAF(tafRawText, forecastStart, forecastEnd) {
        if (!tafRawText) return { category: 'NODATA', rawText: '' };

        const tafValidMatch = tafRawText.match(/(\d{6})Z/);
        const now = new Date();
        let issueTime = new Date(now);
        if (tafValidMatch) {
            const day = parseInt(tafValidMatch[1].substring(0, 2));
            const hour = parseInt(tafValidMatch[1].substring(2, 4));
            issueTime = resolveTafDate(now, day, hour);
        }

        const blocks = parseTafToBlocks(tafRawText, issueTime);
        blocks.sort((a, b) => a.start - b.start);

        const winStart = forecastStart.getTime();
        const winEnd = forecastEnd.getTime();

        // 1. Initialize state at the start of the window
        let activeState = "";
        const initialBlocks = blocks.filter(b => (b.type === 'BASE' || b.type === 'CHANGE') && b.start <= winStart);
        initialBlocks.sort((a,b) => a.start - b.start);

        initialBlocks.forEach(b => {
             if (b.type === 'BASE') activeState = b.text;
             else activeState = mergeCondition(activeState, b.text);
        });

        let worstCategory = analyzeCondition(activeState);
        let worstToken = activeState;

        let timePoints = new Set();
        timePoints.add(winStart);
        timePoints.add(winEnd);
        blocks.forEach(b => {
             if (b.start > winStart && b.start < winEnd) timePoints.add(b.start);
             if (b.end && b.end > winStart && b.end < winEnd) timePoints.add(b.end);
        });
        let sortedPoints = Array.from(timePoints).sort((a,b) => a - b).filter(t => t <= winEnd);

        function updateWorst(cat, text) {
            const currentPrio = getCategoryPriority(cat);
            const worstPrio = getCategoryPriority(worstCategory);
            if (currentPrio > worstPrio) {
                worstCategory = cat;
                worstToken = text;
            }
        }

        for (let i = 0; i < sortedPoints.length; i++) {
            const segStart = sortedPoints[i];
            const segEnd = (i < sortedPoints.length - 1) ? sortedPoints[i+1] : winEnd;
            if (segEnd <= segStart) continue;

            // Prevailing State
            let segState = "";
            const pastBlocks = blocks.filter(b => (b.type === 'BASE' || b.type === 'CHANGE') && b.start <= segStart);
            pastBlocks.sort((a, b) => a.start - b.start);
            pastBlocks.forEach(b => {
                if (b.type === 'BASE') segState = b.text;
                else segState = mergeCondition(segState, b.text);
            });

            updateWorst(analyzeCondition(segState), segState);

            // TEMPO blocks
            const activeTempos = blocks.filter(b => b.type === 'TEMP' && b.start < segEnd && b.end > segStart);
            activeTempos.forEach(tmp => {
                const tempoState = mergeCondition(segState, tmp.text);
                // FIX: Pass the merged 'tempoState' so the wind from 'segState' is preserved
                updateWorst(analyzeCondition(tempoState), tempoState);
            });
        }

        return { category: worstCategory, rawText: worstToken };
    }

    function extractConditionString(text) {
        if (!text) return "";
        let clean = cleanRawText(text);
        clean = clean.replace(/^(TAF|AMD|COR)\s+/g, '');
        clean = clean.replace(/^[A-Z]{4}\s+/g, '');
        clean = clean.replace(/^\d{6}Z\s+/g, '');
        clean = clean.replace(/^\d{4}\/\d{4}\s+/g, '');
        clean = clean.replace(/\b(FM\d{6}|BECMG|TEMPO|PROB\d{2}(\s+TEMPO)?|PROB\d{2})\b/g, '');
        clean = clean.replace(/\b\d{4}\/\d{4}\b/g, '');
        clean = clean.replace(/\b([0-9]{3}|VRB|[/]{3})[0-9]{2,3}(G[0-9]{2,3})?KT\b/g, '');
        clean = clean.replace(/\b([0-9]{3}|VRB|[/]{3})[0-9]{2,3}MPS\b/g, '');
        clean = clean.replace(/\bT[XN].+?\b/g, '');
        clean = clean.replace(/\b(QNH|Q|A)[0-9]{4}(INS)?\b/g, '');
        clean = clean.replace(/\bWS\d{3}\/\d{5}KT\b/g, '');
        const tokens = clean.split(/\s+/).filter(t => t.trim() !== '');
        const significant = [];

        for (const t of tokens) {
            if (/^(M)?(\d+(\/\d+)?)SM$/.test(t)) {
                let numPart = t.replace('SM','').replace('M','');
                let val = 0;
                if (numPart.includes('/')) {
                    const parts = numPart.split('/');
                    num = parseInt(parts[0]) / parseInt(parts[1]);
                } else {
                    val = parseFloat(numPart);
                }
                if (t.startsWith('M') || val <= 5) significant.push(t);
                continue;
            }
            if (t === 'P6SM') continue;
            if (/^\d{4}$/.test(t)) {
                if (parseInt(t) < 9999) significant.push(t);
                continue;
            }
            const cloudMatch = t.match(/^([A-Z]{2,3})(\d{3})([A-Z]{2,3})?$/);
            if (cloudMatch) {
                const type = cloudMatch[1];
                const height = parseInt(cloudMatch[2]);
                if (type === 'VV' || (['BKN', 'OVC'].includes(type) && height < 30)) significant.push(t);
                continue;
            }
            if (/^([-+]|VC)?(RA|SN|DZ|SG|IC|PL|GR|GS|UP|TS|SH|FZ|BR|FG|HZ|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)+$/.test(t)) {
                significant.push(t);
                continue;
            }
            if (t === 'NSW') continue;
        }
        return significant.join(' ');
    }


    function processData(tafDoc, metarDoc, stationMap, homeIcao, runwayMap, minRunwayLen, customRefCoords) {
        const stationDataMap = new Map();
        const getOrCreateStation = (id) => {
            if (!stationDataMap.has(id)) {
                const metadata = stationMap.get(id) || {};
                stationDataMap.set(id, {
                    id: id,
                    name: metadata.name || '',
                    latitude: metadata.latitude || null,
                    longitude: metadata.longitude || null,
                    elevationFt: metadata.elevationFt || null, // Ensure elevation is retrieved
                    distanceNM: null,
                    metar: null,
                    taf: null,
                });
            }
            return stationDataMap.get(id);
        };

        metarDoc.querySelectorAll("METAR").forEach(node => {
            const stationId = node.querySelector("station_id")?.textContent?.trim();
            if (!stationId) return;
            const station = getOrCreateStation(stationId);
            
            // 1. Get RH and Temp
            const { tempF, tempC, rh, rawDewC, rawRh } = calculateTempFAndRH(node);

            const altimInHg = parseFloat(node.querySelector("altim_in_hg")?.textContent);
            const rawTempC = parseFloat(node.querySelector("temp_c")?.textContent);

            // 2. Get Wind
            const windDir = parseInt(node.querySelector("wind_dir_degrees")?.textContent);
            const windSpeed = parseInt(node.querySelector("wind_speed_kt")?.textContent);

            const densityAlt = calculateDensityAltitude(station.elevationFt, rawTempC, altimInHg);

            // --- NEW: Calculate Feels Like (Wind Chill / Heat Index) ---
            // Passing rawRh obtained from step 1
            const feelsLikeData = calculateFeelsLike(rawTempC, windSpeed, rawRh);
            // ------------------------------------------------------------

            const rawText = node.querySelector("raw_text")?.textContent?.trim() || 'N/A';
            const category = node.querySelector("flight_category")?.textContent?.trim() || analyzeCondition(rawText);
            const obsTimeText = node.querySelector("observation_time")?.textContent;
            const metarAgeMinutes = calculateAgeInMinutes(obsTimeText);

            station.metar = {
                rawText, category, tempF, tempC, rh, rawDewC, densityAlt,
                feelsLike: feelsLikeData, // <--- Add to object
                age: metarAgeMinutes, obsTime: obsTimeText,
                windDir: isNaN(windDir) ? null : windDir,
                windSpeed: isNaN(windSpeed) ? null : windSpeed,
                altimInHg: isNaN(altimInHg) ? null : altimInHg,
                rawTempC: rawTempC 
            };
        });

        tafDoc.querySelectorAll("TAF").forEach(node => {
            const stationId = node.querySelector("station_id")?.textContent?.trim();
            if (!stationId) return;
            const station = getOrCreateStation(stationId);
            const rawText = node.querySelector("raw_text")?.textContent?.trim() || 'N/A';
            const validToText = node.querySelector("valid_time_to")?.textContent;
            const issueTimeText = node.querySelector("issue_time")?.textContent;
            const tafAgeMinutes = calculateAgeInMinutes(issueTimeText);
            let periodHours = null;
            let validToDate = null;
            if (validToText) {
                try {
                    validToDate = new Date(validToText);
                    const now = new Date();
                    const hoursRemaining = (validToDate.getTime() - now.getTime()) / (1000 * 60 * 60);
                    periodHours = Math.max(0, Math.round(hoursRemaining));
                } catch (e) {}
            }
            station.taf = { rawText, periodHours, age: tafAgeMinutes, issueTime: issueTimeText, validTo: validToDate };
        });

        // AUTO-SORT LOGIC REPLACEMENT
        // Priority: GPS -> Home -> Dep -> Dest -> Null

        let refLat = null, refLon = null, refName = null;

        if (customRefCoords) {
            refLat = customRefCoords.lat;
            refLon = customRefCoords.lon;
            refName = "Your Location";
        } else {
            let refIcao = null;
            if (homeIcao && homeIcao.length >= 3) refIcao = homeIcao;
            else if (document.getElementById('depIcao').value.trim().length >= 3) refIcao = document.getElementById('depIcao').value.trim();
            else if (document.getElementById('destIcao').value.trim().length >= 3) refIcao = document.getElementById('destIcao').value.trim();

            if (refIcao) {
                const refStationData = getCoordsForICAO(refIcao, stationMap);
                if (refStationData && refStationData.lat !== null) {
                    refLat = refStationData.lat;
                    refLon = refStationData.lon;
                    const refStationName = stationDataMap.get(refIcao.toUpperCase());
                    refName = `${refIcao.toUpperCase()} (${(refStationName && refStationName.name) || 'Unknown'})`;
                }
            }
        }

        let allStations = Array.from(stationDataMap.values()); // Unfiltered

        if (refLat !== null && refLon !== null) {
            for (let station of allStations) {
                if (station.latitude !== null && station.longitude !== null) {
                    station.distanceNM = haversineDistance(refLat, refLon, station.latitude, station.longitude);
                }
            }
        }

        // CREATE FILTERED LIST
        let stations = [...allStations];

        // Filter by Runway Length
        if (runwayMap && minRunwayLen > 0) {
            stations = stations.filter(s => {
                // OLD: const maxLen = runwayMap.get(s.id);
                // NEW:
                const entry = runwayMap.get(s.id);
                return entry && entry.maxLen >= minRunwayLen;
            });
        }

        if (refLat !== null) {
            // Sort by Distance
            stations.sort((a, b) => {
                if (a.distanceNM === null && b.distanceNM === null) return a.id.localeCompare(b.id);
                if (a.distanceNM === null) return 1;
                if (b.distanceNM === null) return -1;
                return a.distanceNM - b.distanceNM;
            });
        } else {
            // Sort Alphabetically
            stations.sort((a, b) => a.id.localeCompare(b.id));
        }

        // Return both the Filtered list AND the Raw list
        return {
            stations: stations,
            allStations: allStations, // Added for interpolation
            refName,
            stationDataMap
        };
    }

    function runRouteAnalysis(stationDataMap, depIcao, destIcao, takeOffTime, landingTime, maxDistanceInput, runwayMap, minRunwayLen) {
        const dep = depIcao ? depIcao.toUpperCase() : null;
        const dest = destIcao ? destIcao.toUpperCase() : null;
        const distLimit = maxDistanceInput || MAX_ROUTE_DISTANCE_NM;

        const depResults = [];
        const destResults = [];
        const now = new Date();
        const ONE_HOUR = 60 * 60 * 1000;

        let takeoffStart = null, takeoffEnd = null;
        let landingStart = null, landingEnd = null;
        let depName = 'N/A', destName = 'N/A';

     // Helper to check runway
const meetsRunwayReq = (id) => {
    if (!runwayMap || minRunwayLen <= 0) return true;
    const entry = runwayMap.get(id); // Rename for clarity
    // Check if entry exists AND if its maxLen property meets the requirement
    return entry && entry.maxLen >= minRunwayLen;
};

        if (dep) {
            const depCoords = getCoordsForICAO(dep, cachedStationMap);
            if (depCoords && depCoords.lat !== null) {
                depName = stationDataMap.get(dep)?.name || dep;
                const toDate = takeOffTime ? parseUtcString(takeOffTime) : null;
                if (toDate) {
                    takeoffStart = new Date(toDate.getTime() - ONE_HOUR);
                    takeoffEnd = new Date(toDate.getTime() + ONE_HOUR);
                    for (const station of stationDataMap.values()) {
                        if (station.latitude === null || station.longitude === null || !station.taf || !meetsRunwayReq(station.id)) continue;
                        const distToDep = haversineDistance(depCoords.lat, depCoords.lon, station.latitude, station.longitude);
                        if (distToDep <= distLimit) {
                            if (!station.taf.validTo || station.taf.validTo >= takeoffStart) {
                                const analysis = getWorstFlightCategoryFromTAF(station.taf.rawText, takeoffStart, takeoffEnd);
                                const conditionText = (analysis.category !== 'VFR' && analysis.category !== 'NODATA') ? extractConditionString(analysis.rawText) : '';
                                depResults.push({
                                    id: station.id,
                                    name: station.name,
                                    worstCategory: analysis.category,
                                    conditionText: conditionText,
                                    distance: distToDep,
                                    tafRawText: station.taf.rawText,
                                    latitude: station.latitude,
                                    longitude: station.longitude
                                });
                            }
                        }
                    }
                    depResults.sort((a, b) => a.distance - b.distance);
                }
            }
        }

        if (dest) {
            const destCoords = getCoordsForICAO(dest, cachedStationMap);
            if (destCoords && destCoords.lat !== null) {
                destName = stationDataMap.get(dest)?.name || dest;
                const lDate = landingTime ? parseUtcString(landingTime) : null;
                if (lDate) {
                    landingStart = new Date(lDate.getTime() - ONE_HOUR);
                    landingEnd = new Date(lDate.getTime() + ONE_HOUR);
                    for (const station of stationDataMap.values()) {
                        if (station.latitude === null || station.longitude === null || !station.taf || !meetsRunwayReq(station.id)) continue;
                        const distToDest = haversineDistance(destCoords.lat, destCoords.lon, station.latitude, station.longitude);
                        if (distToDest <= distLimit) {
                            if (!station.taf.validTo || station.taf.validTo >= landingStart) {
                                const analysis = getWorstFlightCategoryFromTAF(station.taf.rawText, landingStart, landingEnd);
                                const conditionText = (analysis.category !== 'VFR' && analysis.category !== 'NODATA') ? extractConditionString(analysis.rawText) : '';
                                destResults.push({
                                    id: station.id,
                                    name: station.name,
                                    worstCategory: analysis.category,
                                    conditionText: conditionText,
                                    distance: distToDest,
                                    tafRawText: station.taf.rawText,
                                    latitude: station.latitude,
                                    longitude: station.longitude
                                });
                            }
                        }
                    }
                    destResults.sort((a, b) => a.distance - b.distance);
                }
            }
        }

        return {
            depResults, destResults,
            takeoffStart, takeoffEnd, landingStart, landingEnd,
            depName: dep || 'N/A', destName: dest || 'N/A',
            searchDistance: distLimit
        };
    }

    // Auto-center map helper
    function centerMapOnHome() {
        if (!mapInstance || !cachedStationMap) return;
        const homeInput = document.getElementById('icaoInput').value.trim().toUpperCase();
        if (homeInput.length >= 3) {
             const homeCoords = getCoordsForICAO(homeInput, cachedStationMap);
             if (homeCoords && homeCoords.lat !== null) {
                 mapInstance.setView([homeCoords.lat, homeCoords.lon], 7);
             }
        }
    }

    // --- AUTO REFRESH LOGIC ---
    function startAutoRefresh() {
        if (refreshIntervalId) clearInterval(refreshIntervalId);
        // Set refresh to 60 seconds
        refreshIntervalId = setInterval(refreshDataSilent, 60000);
    }

    function stopAutoRefresh() {
        if (refreshIntervalId) {
            clearInterval(refreshIntervalId);
            refreshIntervalId = null;
        }
    }

   // New helper to create station card
   // Updated to make elements clickable
    function createStationCard(data) {
        const metar = data.metar;
        const taf = data.taf;
        
        let metarHtml = '<div class="text-gray-500 dark:text-gray-400 italic">No METAR available.</div>';
        let tafHtml = '<div class="text-gray-500 dark:text-gray-400 italic">No TAF available.</div>';
        
        let headerText = data.id;
        if (data.name) headerText += ` <span class="text-base font-normal text-gray-500 dark:text-gray-400 ml-2 block sm:inline">${data.name}</span>`;
        let infoTextParts = [];

        if (metar) {
            const category = metar.category;
            const className = getCategoryClassName(category);

            // 1. Temp & RH
            infoTextParts.push(`${getDisplayTemp(metar)} ‚Ä¢ ${metar.rh}`);

            // 2. Feels Like
            if (metar.feelsLike) {
                const valStr = useCelsius ? `${metar.feelsLike.c}¬∞C` : `${metar.feelsLike.f}¬∞F`;
                const label = metar.feelsLike.label;
                const colorClass = label === 'Wind Chill' 
                    ? 'text-cyan-600 dark:text-cyan-400 border-cyan-200 dark:border-cyan-800' 
                    : 'text-orange-600 dark:text-orange-400 border-orange-200 dark:border-orange-800';
                infoTextParts.push(`<span class="${colorClass} font-bold text-[10px] uppercase tracking-wide border px-1.5 rounded-sm select-none">${label}: ${valStr}</span>`);
            }

            if (metar.densityAlt) infoTextParts.push(metar.densityAlt); 
            infoTextParts.push(`Observed ${formatAge(metar.age)}`);
            if (data.distanceNM !== null) infoTextParts.push(`${data.distanceNM.toFixed(0)} NM`);
            
            const dotClassToBorderColor = {
                'vfr-dot': 'border-green-500',
                'mvfr-dot': 'border-blue-600', 
                'ifr-dot': 'border-red-500',
                'lifr-dot': 'border-pink-500'
            };
            const borderColorClass = dotClassToBorderColor[className] || 'border-gray-500';
            
            // --- UPDATED: Added onclick and cursor-pointer ---
            metarHtml = `<div onclick="openDashDetail('${data.id}', true)" 
                             class="bg-gray-100 dark:bg-gray-900 p-2 rounded-lg border-l-4 ${borderColorClass} transition-all duration-300 w-full overflow-hidden cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-800 hover:shadow-md group">
                            <div class="flex justify-between items-center mb-1">
                                <h4 class="font-bold text-sm text-gray-600 dark:text-gray-300 group-hover:text-blue-600 dark:group-hover:text-blue-400">METAR</h4>
                                <span class="text-[10px] text-blue-500 opacity-0 group-hover:opacity-100 transition-opacity">View Fullscreen</span>
                            </div>
                            <div class="font-mono text-xs md:text-sm leading-relaxed break-words whitespace-pre-wrap">${formatRawText(metar.rawText)}</div>
                         </div>`;
        } else if (data.distanceNM !== null) {
            infoTextParts.push(`Distance: ${data.distanceNM.toFixed(0)} NM`);
        }

        if (taf) {
            let notes = [];
            if (taf.age !== null) notes.push(`Issued ${formatAge(taf.age)}`);
            if (taf.periodHours !== null) notes.push(`Forecast period ends in ${taf.periodHours} hours`);
            let noteHtml = notes.length > 0 ? `<p class="text-xs text-gray-500 dark:text-gray-400 mt-2">${notes.join(' ‚Ä¢ ')}</p>` : '';
            
            tafHtml = `<div class="bg-gray-100 dark:bg-gray-900 p-2 rounded-lg transition-colors duration-300 w-full overflow-hidden">
                        <h4 class="font-bold mb-1 text-sm text-gray-600 dark:text-gray-300">TAF</h4>
                        <div class="space-y-1">${formatRawText(taf.rawText)}</div>
                        ${noteHtml}
                     </div>`;
        }

        const stationEntry = document.createElement('div');
        stationEntry.className = 'border border-gray-200 dark:border-gray-800 rounded-lg p-4 shadow-md bg-white dark:bg-black transition-colors duration-300 w-full max-w-full mb-4';
        
        // --- UPDATED: Header is clickable ---
        stationEntry.innerHTML = `
            <div class="flex flex-col items-start mb-3 border-b dark:border-gray-800 pb-2">
                <button onclick="openDashDetail('${data.id}', true)" class="text-xl font-extrabold text-gray-900 dark:text-gray-100 flex items-baseline flex-wrap gap-2 hover:text-blue-600 dark:hover:text-blue-400 transition-colors text-left">
                    ${headerText}
                    <svg class="w-4 h-4 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/></svg>
                </button>
                <div class="flex flex-wrap items-center gap-x-2 gap-y-1 text-xs text-gray-500 dark:text-gray-400 font-medium mt-1">
                    ${infoTextParts.map(part => `<span>${part}</span>`).join('<span class="opacity-50">‚Ä¢</span>')}
                </div>
            </div>
            <div class="space-y-3 w-full">${metarHtml}${tafHtml}</div>
        `;
        return stationEntry;
    }
    // Lazy Loading Function
    function renderNextBatch() {
        // Validation to ensure data exists
        if (!currentReportData || !currentReportData.stationsData) return;

        // If we have rendered everything, stop.
        if (listRenderIndex >= currentReportData.stationsData.length) return;

        // Slice the next batch
        const batch = currentReportData.stationsData.slice(listRenderIndex, listRenderIndex + LIST_BATCH_SIZE);

        if (batch.length === 0) return;

        const fragment = document.createDocumentFragment();
        batch.forEach(data => {
            fragment.appendChild(createStationCard(data));
        });

        weatherListEl.appendChild(fragment);
        listRenderIndex += batch.length;
    }

    // Helper to fill screen if 20 items isn't enough (e.g. large desktop monitor)
    function fillListContainer() {
        const container = resultsContainerEl.querySelector('.flex-grow');
        if (!container) return;

        // Safety break to prevent infinite loop
        let safeGuard = 0;
        // Keep loading batches until scrollbar appears OR we run out of data
        // We check if container is visible because clientHeight might be 0 if hidden
        if (container.clientHeight > 0) {
            while (container.scrollHeight <= container.clientHeight && listRenderIndex < currentReportData.stationsData.length && safeGuard < 10) {
                renderNextBatch();
                safeGuard++;
            }
        }
    }

   async function refreshDataSilent(skipFetch = false) {
    try {
        if (!skipFetch) {
            const [tafDoc, metarDoc] = await Promise.all([
                fetchAndParse(TAF_DATA_URL),
                fetchAndParse(METAR_DATA_URL)
            ]);

            const validTafs = tafDoc.querySelectorAll("TAF").length;
            const validMetars = metarDoc.querySelectorAll("METAR").length;

            if (validTafs === 0 || validMetars === 0) {
                console.warn("NWS returned empty data. Retaining old data.");
                return; 
            }

            const homeIcao = icaoInput.value.trim().toUpperCase();
            const minRunwayLen = parseInt(minRunwayInput.value) || 0;
            const depIcao = depIcaoInput.value.trim().toUpperCase();
            const destIcao = destIcaoInput.value.trim().toUpperCase();
            const takeOffTime = takeOffTimeInput.value;
            const landingTime = landingTimeInput.value;
            const radiusInputVal = parseInt(searchRadiusInput.value);
            const searchDist = (!isNaN(radiusInputVal) && radiusInputVal > 0) ? radiusInputVal : MAX_ROUTE_DISTANCE_NM;

            const processResult = processData(tafDoc, metarDoc, cachedStationMap, homeIcao, cachedRunwayMap, minRunwayLen, gpsReferenceCoords);
            
            currentReportData = {
                stationsData: processResult.stations,
                refName: processResult.refName,
                routeAnalysisResult: routeAnalysisEnabled ? runRouteAnalysis(processResult.stationDataMap, depIcao, destIcao, takeOffTime, landingTime, searchDist, cachedRunwayMap, minRunwayLen) : null
            };
            currentStationsData = processResult.stations;
            allStationsData = processResult.allStations;
        }

        // 1. Update Map
        if (!document.getElementById('mapView').classList.contains('hidden')) {
            renderMap(currentStationsData);
        }

        // 2. Update Dashboard
        if (!document.getElementById('customDashboardView').classList.contains('hidden')) {
            renderDashboard();
        }

        // 3. Update List
        if (!weatherListEl.classList.contains('hidden')) {
            weatherListEl.innerHTML = '';
            listRenderIndex = 0;
            renderNextBatch();
            fillListContainer();
        }

    } catch (e) {
        console.warn("Auto-refresh failed", e);
    }
}

    async function handleGenerateClick(event, isAutoLoad = false) {
        if (typeof pako === 'undefined') {
            showStatus("Error: Required libraries failed to load.", true);
            return;
        }

        try {
            // Stop any existing refresh timer to avoid overlap
            stopAutoRefresh();

            // Disabled PDF button until new data is ready
            downloadPdfBtn.disabled = true;

            const homeIcao = icaoInput.value.trim().toUpperCase();
            const minRunwayLen = parseInt(minRunwayInput.value) || 0;
            let routeAnalysisResult = null;

            const depIcao = depIcaoInput.value.trim().toUpperCase();
            const destIcao = destIcaoInput.value.trim().toUpperCase();
            const takeOffTime = takeOffTimeInput.value;
            const landingTime = landingTimeInput.value;
            const radiusInputVal = parseInt(searchRadiusInput.value);
            const searchDist = (!isNaN(radiusInputVal) && radiusInputVal > 0) ? radiusInputVal : MAX_ROUTE_DISTANCE_NM;

            if (routeAnalysisEnabled) {
                // Graceful handling: If fields are empty, don't error, just skip analysis (Requirement #2)
                if (depIcao.length < 3 && destIcao.length < 3) {
                     // Proceed without analysis
                     console.log("Analysis enabled but no airports defined. Proceeding as standard report.");
                } else if (takeOffTime && landingTime && takeOffTime >= landingTime) {
                     showStatus("Time Error", true, "Landing time must be after Takeoff time.");
                     return;
                }
            }

            generateButton.disabled = true;
            generateButton.textContent = "Fetching Data...";
            generateButton.classList.add('opacity-50', 'cursor-not-allowed');
            showStatus("Fetching METAR, TAF, and Station Database...", false);
            // resultsContainerEl.classList.add('hidden'); // REMOVED TO PREVENT FLICKER ON RELOAD

       // Inside handleGenerateClick...
const promises = [
    fetchAndParse(TAF_DATA_URL),
    fetchAndParse(METAR_DATA_URL),
    getStationMap()
];

// CHANGED CONDITION:
if (minRunwayLen > 0 || showRunwaysOnMap) {
    showStatus("Fetching METAR, TAF, Stations, and Runway Data...", false);
    promises.push(getRunwayData());
}
            if (minRunwayLen > 0) {
                showStatus("Fetching METAR, TAF, Stations, and Runway Data...", false);
                promises.push(getRunwayData());
            }

            const results = await Promise.all(promises);
            const tafDoc = results[0];
            const metarDoc = results[1];
            const stationMap = results[2];
            const runwayMap = (minRunwayLen > 0) ? results[3] : null;

            // --- DATA VALIDITY CHECK (MANUAL LOAD) ---
            const validTafs = tafDoc.querySelectorAll("TAF").length;
            const validMetars = metarDoc.querySelectorAll("METAR").length;

            if (validTafs === 0 || validMetars === 0) {
                console.warn("NWS returned empty data files. Silently aborting update.");

                // Restore UI state manually since we are returning early
                generateButton.disabled = false;
                generateButton.textContent = "Go!";
                generateButton.classList.remove('opacity-50', 'cursor-not-allowed');

                // Hide any status that might be showing "Fetching Data..."
                statusEl.style.display = 'none';

                if (currentStationsData.length > 0) {
                    // We have old data, ensure PDF is enabled and auto-refresh continues
                    downloadPdfBtn.disabled = false;
                    startAutoRefresh();
                }

                return; // Stop processing, keep existing state
            }
            // ----------------------------------------

            showStatus("Processing stations...");
            const processResult = processData(tafDoc, metarDoc, stationMap, homeIcao, runwayMap, minRunwayLen, gpsReferenceCoords);
            const stationsData = processResult.stations; // FILTERED
            const allStations = processResult.allStations; // UNFILTERED (NEW)
            const stationDataMap = processResult.stationDataMap;
            const usedRef = processResult.refName;


            if (routeAnalysisEnabled && (depIcao.length >= 3 || destIcao.length >= 3)) {
                showStatus("Running Alternate Analysis...");
                routeAnalysisResult = runRouteAnalysis(stationDataMap, depIcao, destIcao, takeOffTime, landingTime, searchDist, runwayMap, minRunwayLen);
            }

            // Save data for PDF Generation and Global State
            currentReportData = {
                stationsData: stationsData,
                refName: usedRef,
                routeAnalysisResult: routeAnalysisResult
            };
            // GLOBAL DATA UPDATE
            currentStationsData = stationsData; // For Map Markers / List
            allStationsData = allStations;      // For Math / Interpolation

            // Only show Analysis tab if we actually have results
            if (routeAnalysisResult) tabRouteAnalysis.classList.remove('hidden');
            else tabRouteAnalysis.classList.add('hidden');

            // Render to browser and enable PDF button
            renderInBrowser(stationsData, usedRef, routeAnalysisResult);

            // FIX: Default to Map Tab
            switchTab('map');

            // Center map (Initial Generate Only)
            centerMapOnHome();

            showSuccess(`Report displayed ‚Äì ${stationsData.length} stations`);
            downloadPdfBtn.disabled = false;

            // Start Auto Refresh
            startAutoRefresh();

            // Auto-Scroll to Results Logic
            // If it's an auto-load (app startup), do NOT scroll.
            // If the user clicked the button (event is present or !isAutoLoad), DO scroll.
            if (!isAutoLoad) {
                setTimeout(() => {
                    resultsContainerEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }

        } catch (error) {
            console.error(error);
            showStatus(`Error: ${error.message}`, true, "Check console for details.");
        } finally {
            generateButton.disabled = false;
            generateButton.textContent = "Go!"; // Updated Text
            generateButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    }

    // --- MODAL TAF DISPLAY LOGIC ---
    function formatAnalyzedTaf(tafRawText, windowStart, windowEnd) {
        if (!tafRawText) return 'No TAF Data';

        const tafValidMatch = tafRawText.match(/(\d{6})Z/);
        const now = new Date();
        let issueTime = new Date(now);
        if (tafValidMatch) {
            const day = parseInt(tafValidMatch[1].substring(0, 2));
            const hour = parseInt(tafValidMatch[1].substring(2, 4));
            issueTime = resolveTafDate(now, day, hour);
        }

        const blocks = parseTafToBlocks(tafRawText, issueTime);
        const winStart = windowStart.getTime();
        const winEnd = windowEnd.getTime();

        let htmlParts = [];

        for (const block of blocks) {
            // Visual Highlighting Logic:
            // Highlight if window overlaps [start, visualEnd]
            const effectiveEnd = block.visualEnd;
            const isOverlap = block.start < winEnd && effectiveEnd > winStart;

            const styleClass = isOverlap
                ? 'font-bold bg-white/25 rounded px-2 py-1 shadow-sm border-l-2 border-yellow-400'
                : 'opacity-50 px-2 py-0.5 text-xs';

            const highlightedToken = block.text.split(' ').map(word => {
                return isPrecipOrTS(word) ? `<span class="underline decoration-2">${word}</span>` : word;
            }).join(' ');

            htmlParts.push(`<div class="mb-1 transition-all ${styleClass}">${highlightedToken}</div>`);
        }
        return htmlParts.join('');
    }

    function openTileModal(stationId, type) {
        const dataSet = g_analysisData[type];
        if (!dataSet) return;

        const station = dataSet.results.find(s => s.id === stationId);
        if (!station) return;

        // Calculate colors based on worst category
        const cat = station.worstCategory;
        const tileClass = getCategoryTileClassName(cat);
        const dotColor = getCategoryColor(cat);
        const textColor = (dotColor[0] + dotColor[1] + dotColor[2]) > 300 ? 'text-gray-900' : 'text-white';

        // Apply tile colors to modal container
        const modalContainer = document.querySelector('#tileModal > div');
        modalContainer.className = `rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col modal-enter transition-all transform border-none ${tileClass} ${textColor}`;

        // Generate Simplified Content (Large Tile Look)
        const tafHtml = formatAnalyzedTaf(station.tafRawText, dataSet.start, dataSet.end);

        const contentEl = document.getElementById('modalContent');

        // Reset container to just this content (removing old header/footer structure if any)
        modalContainer.innerHTML = `
            <div class="relative p-6 flex flex-col h-full" onclick="event.stopPropagation()">
                <button onclick="closeTileModal()" class="absolute top-4 right-4 p-2 rounded-full hover:bg-white/20 transition-colors focus:outline-none z-50">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 ${textColor}" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>

                <div class="flex flex-col items-start mb-6 shrink-0">
                    <h3 class="text-4xl font-bold font-mono tracking-wider">${station.id}</h3>
                    <p class="text-lg opacity-80 font-medium">${station.name || 'Unknown'}</p>
                    <div class="mt-2 inline-block px-3 py-1 rounded border ${textColor === 'text-white' ? 'border-white/40' : 'border-black/20'} text-sm font-bold">
                        ${cat}
                    </div>
                </div>

                <div class="flex-grow overflow-y-auto pr-2 custom-scrollbar">
                    <div class="font-mono text-base whitespace-pre-wrap leading-relaxed">
                        ${tafHtml}
                    </div>
                </div>
            </div>
        `;

        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
    }

    function renderRouteAnalysisBrowser(analysisResult) {
        const { depResults, destResults, takeoffStart, takeoffEnd, landingStart, landingEnd, depName, destName, searchDistance } = analysisResult;

        // Update Global Data for Modal
        g_analysisData.dep = { results: depResults, start: takeoffStart, end: takeoffEnd };
        g_analysisData.dest = { results: destResults, start: landingStart, end: landingEnd };

        routeAnalysisViewEl.innerHTML = '';
        const tStart = takeoffStart ? formatTimeHHMM(takeoffStart) : 'N/A';
        const tEnd = takeoffEnd ? formatTimeHHMM(takeoffEnd) : 'N/A';
        const lStart = landingStart ? formatTimeHHMM(landingStart) : 'N/A';
        const lEnd = landingEnd ? formatTimeHHMM(landingEnd) : 'N/A';

        const headerHtml = `
            <div class="p-4 rounded-xl bg-blue-50 dark:bg-blue-900/30 mb-6 shadow-md text-center transition-colors duration-300">
                <h3 class="text-xl font-bold text-blue-800 dark:text-blue-200">
                    Alternate Analysis
                </h3>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-2 italic">
                    Stations within ${searchDistance} NM. Click a tile for details.
                </p>
            </div>
        `;
        routeAnalysisViewEl.insertAdjacentHTML('beforeend', headerHtml);

        const generateGrid = (items, type) => {
             if (!items || items.length === 0) return `<div class="text-center p-4 text-gray-500 italic">No alternates found within range.</div>`;

             const tiles = items.map(data => {
                const className = getCategoryTileClassName(data.worstCategory);
                const dotColor = getCategoryColor(data.worstCategory);
                const textColor = (dotColor[0] + dotColor[1] + dotColor[2]) > 300 ? 'text-gray-900' : 'text-white';
                const conditionHtml = data.conditionText ? `<span class="text-[10px] font-mono ${textColor} opacity-90 text-center break-words leading-tight px-1">${data.conditionText}</span>` : '';

                return `
                    <button class="w-full text-left p-2 rounded-lg shadow-md ${className} flex flex-col items-center justify-start space-y-1 transition-all duration-200 cursor-pointer min-h-[100px] hover:scale-[1.05] hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-white/50"
                         onclick="openTileModal('${data.id}', '${type}')"
                         aria-label="View details for ${data.id}">

                        <span class="font-bold text-lg font-mono ${textColor}">${data.id}</span>
                        <span class="text-xs ${textColor} opacity-80 text-center w-full truncate px-1">${data.name || 'N/A'}</span>
                        <div class="flex flex-col items-center">
                             <span class="text-xs font-bold ${textColor} opacity-100">${data.worstCategory}</span>
                             ${conditionHtml}
                        </div>
                        <span class="text-[10px] ${textColor} opacity-70 mt-auto pt-1">${data.distance.toFixed(0)} NM</span>
                    </button>
                `;
             }).join('');
             return `<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 transition-all">${tiles}</div>`;
        };

        if (takeoffStart && depName !== 'N/A') {
            const depSection = `
                <details class="group bg-white dark:bg-gray-900 rounded-xl shadow-md border border-gray-200 dark:border-gray-800 mb-4 transition-all duration-300" open>
                    <summary class="list-none flex items-center justify-between p-4 cursor-pointer focus:outline-none">
                        <div class="flex flex-col">
                            <h4 class="text-lg font-bold text-gray-800 dark:text-gray-100 flex items-center gap-2">
                                Departure: ${depName}
                            </h4>
                            <span class="text-xs font-mono text-gray-500 dark:text-gray-400">Window: ${tStart} - ${tEnd}</span>
                        </div>
                        <svg class="w-6 h-6 text-gray-500 transform group-open:rotate-180 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </summary>
                    <div class="p-4 border-t border-gray-100 dark:border-gray-800">
                        ${generateGrid(depResults, 'dep')}
                    </div>
                </details>
            `;
            routeAnalysisViewEl.insertAdjacentHTML('beforeend', depSection);
        }

        if (landingStart && destName !== 'N/A') {
            const destSection = `
                <details class="group bg-white dark:bg-gray-900 rounded-xl shadow-md border border-gray-200 dark:border-gray-800 mb-4 transition-all duration-300" open>
                    <summary class="list-none flex items-center justify-between p-4 cursor-pointer focus:outline-none">
                        <div class="flex flex-col">
                            <h4 class="text-lg font-bold text-gray-800 dark:text-gray-100 flex items-center gap-2">
                                Destination: ${destName}
                            </h4>
                            <span class="text-xs font-mono text-gray-500 dark:text-gray-400">Window: ${lStart} - ${lEnd}</span>
                        </div>
                        <svg class="w-6 h-6 text-gray-500 transform group-open:rotate-180 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                    </summary>
                    <div class="p-4 border-t border-gray-100 dark:border-gray-800">
                        ${generateGrid(destResults, 'dest')}
                    </div>
                </details>
            `;
            routeAnalysisViewEl.insertAdjacentHTML('beforeend', destSection);
        }
    }

    function renderInBrowser(stationsData, refName, routeAnalysisResult) {
        weatherListEl.innerHTML = '';
        listRenderIndex = 0; // Reset index

        // --- MAP DATA HANDLER ---
        currentStationsData = stationsData;
        renderMap(currentStationsData);
        // --- END MAP DATA HANDLER ---

        // Prepare List View
        if (refName) {
            const refHeader = document.createElement('div');
            refHeader.className = "bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg mb-4 text-center text-sm font-bold text-blue-800 dark:text-blue-200 transition-colors duration-300";
            refHeader.textContent = `Distances calculated from: ${refName}`;
            weatherListEl.appendChild(refHeader);
        }

        // Render First Batch Only (Immediate Performance Gain)
        renderNextBatch();

        // Check if we need more to fill the screen
        fillListContainer();

        if (routeAnalysisResult) {
            renderRouteAnalysisBrowser(routeAnalysisResult);
            switchTab('standard');
        } else {
            tabRouteAnalysis.classList.add('hidden');
            switchTab('standard');
        }
        resultsContainerEl.classList.remove('hidden');
    }

function mergeCondition(baseStr, changeStr) {
        let newStr = baseStr;
        const cleanChange = cleanRawText(changeStr);

        // Regex Definitions
        const windRegex = /\b([0-9]{3}|VRB)[0-9]{2,3}(G[0-9]{2,3})?KT\b/g;
        // Clouds: BKN005, OVC010, VV002, SKC, CLR, NSC
        const cloudRegex = /\b(BKN|OVC|VV|SCT|FEW|SKC|CLR|NSC)\d{0,3}(?:CB|TCU)?\b/g;
        // Vis: 10SM, 1 1/2SM, 4000, 9999. 
        // FIX: Use Lookbehind/Lookahead to ensure we don't match time groups like 2120/2123
        const visRegex = /\b(?<!\/)\d{4}(?!\/)\b|\b(?:M|P)?\d+(?:\s?\d\/\d)?SM\b/g;
        const wxRegex = /\b([-+]|VC)?(RA|SN|DZ|SG|IC|PL|GR|GS|UP|TS|SH|FZ|BR|FG|HZ|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)+\b/g;
        const nswRegex = /\bNSW\b/;

        // 1. Wind Update
        if (windRegex.test(cleanChange)) {
            newStr = newStr.replace(windRegex, ""); 
        }

        // 2. CAVOK Handling
        if (/\bCAVOK\b/.test(cleanChange)) {
            // Remove Clouds, Vis, Wx (Keep Wind)
            // Note: We use a simpler regex for removal to ensure we catch everything
            const simpleVisRegex = /\b(?:M|P)?\d+(?:\s?\d\/\d)?SM\b|\b\d{4}\b/g;
            newStr = newStr.replace(cloudRegex, "").replace(simpleVisRegex, "").replace(wxRegex, "");
        } 
        else {
            // 3. Normal Updates
            
            // Visibility
            if (visRegex.test(cleanChange)) {
                // Remove old visibility using the broad regex to be safe
                const removeVisRegex = /\b(?:M|P)?\d+(?:\s?\d\/\d)?SM\b|\b\d{4}\b/g;
                newStr = newStr.replace(removeVisRegex, "");
            }

            // Weather (NSW clears old weather)
            if (nswRegex.test(cleanChange)) {
                newStr = newStr.replace(wxRegex, "");
            } else if (wxRegex.test(cleanChange)) {
                newStr = newStr.replace(wxRegex, "");
            }

            // Clouds
            if (cloudRegex.test(cleanChange)) {
                newStr = newStr.replace(cloudRegex, "");
            }
        }

        // Clean up
        newStr = newStr.replace(/\s+/g, " ").trim();
        return (newStr + " " + cleanChange).trim();
    }

   function formatRawText(rawText) {
    if (!rawText) return "";

    // FIXED REGEX: Prioritize "PROB.. TEMPO" combo before single "TEMPO" or "PROB"
    // This prevents splitting them into two lines.
    let formatted = rawText.replace(/\s(FM\d{6}|BECMG|PROB\d{2}\s+TEMPO|TEMPO|PROB\d{2})/g, "\n$1");
    
    const lines = formatted.split('\n').map(l => l.trim()).filter(l => l);
    
    let html = '';
    let currentPrevailing = ""; 

    for (const line of lines) {
        const cleanLine = line.replace(/<[^>]*>?/gm, '');
        
        // Detect Type
        const isFm = /^FM/.test(cleanLine);
        const isBecmg = /^BECMG/.test(cleanLine);
        // "PROB40 TEMPO" will match here correctly as a tempo block
        const isTempo = /^(TEMPO|PROB)/.test(cleanLine);
        
        let effectiveCondition = "";

        if (isFm) {
            currentPrevailing = cleanLine;
            effectiveCondition = currentPrevailing;
        } 
        else if (isBecmg) {
            currentPrevailing = mergeCondition(currentPrevailing, cleanLine);
            effectiveCondition = currentPrevailing;
        } 
        else if (isTempo) {
            effectiveCondition = mergeCondition(currentPrevailing, cleanLine);
        } 
        else {
            if (currentPrevailing === "") currentPrevailing = cleanLine;
            else currentPrevailing = mergeCondition(currentPrevailing, cleanLine);
            effectiveCondition = currentPrevailing;
        }

        const category = analyzeCondition(effectiveCondition);
        const className = getCategoryClassName(category);
        
        // Visual Styling: Highlight the keywords (now handling the combined keyword too)
        const displayLine = line.replace(/^(FM\d{6}|BECMG|PROB\d{2}\s+TEMPO|PROB\d{2}|TEMPO)/, "<span class='font-bold text-white'>$1</span>");
        
        const highlightedLine = displayLine.split(' ').map(word => {
            if (word.includes('<span')) return word;
            return isPrecipOrTS(word) ? `<span class="font-bold underline decoration-1 underline-offset-2">${word}</span>` : word;
        }).join(' ');

        const bgClass = {
            'vfr-dot': 'bg-green-600',
            'mvfr-dot': 'bg-blue-600', 
            'ifr-dot': 'bg-red-600',
            'lifr-dot': 'bg-pink-600'
        }[className] || 'bg-gray-500';

        html += `<div class="font-mono text-xs md:text-sm leading-relaxed p-1.5 mb-1 rounded-md text-white ${bgClass} break-words whitespace-pre-wrap shadow-sm border-l-4 border-black/20">${highlightedLine}</div>`;
    }
    return html;
}
    function isPrecipOrTS(word) {
        const clean = word.replace(/[,.;]+$/, '').toUpperCase();
        const regex = /^([-+]|VC)?(RA|SN|DZ|SG|IC|PL|GR|GS|UP|TS|SH|FZ|BR|FG|HZ|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS){1,4}$/i;
        return regex.test(clean);
    }

  function generatePDF(stationsData, refName, routeAnalysisResult) {
    if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("PDF Library failed to load. Please reload the page.");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });

    const drawStyledText = (doc, lineText, x, y, baseColor) => {
        const words = lineText.split(' ');
        let currentX = x;
        doc.setTextColor(...baseColor);
        doc.setFont("courier", "normal");
        doc.setFontSize(9);
        const spaceWidth = doc.getTextWidth(" ");
        for (let word of words) {
            const shouldBold = (typeof isPrecipOrTS === 'function') ? isPrecipOrTS(word) : false;
            doc.setFont("courier", shouldBold ? "bold" : "normal");
            doc.text(word, currentX, y);
            currentX += doc.getTextWidth(word) + spaceWidth;
        }
    };

    const drawPdfLegend = (doc, cursorY) => {
        doc.setFont("helvetica", "bold");
        doc.setFontSize(10);
        doc.setTextColor(0, 0, 0);
        doc.text("METAR Flight Categories", PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 6;
        const legendItems = [
            { label: "VFR", color: [0, 170, 0] },     
            { label: "MVFR", color: [37, 99, 235] },
            { label: "IFR", color: [200, 0, 0] },
            { label: "LIFR", color: [255, 20, 147] },
            { label: "NODATA", color: [150, 150, 150] }
        ];
        const itemWidth = 30;
        const totalLegendWidth = legendItems.length * itemWidth;
        const startX = (PAGE_WIDTH - totalLegendWidth) / 2;
        const boxSize = 4;
        
        for (let i = 0; i < legendItems.length; i++) {
            const x = startX + i * itemWidth;
            const item = legendItems[i];
            doc.setFillColor(...item.color);
            doc.rect(x, cursorY - 3, boxSize, boxSize, 'F');
            doc.setFont("helvetica", "normal");
            doc.setFontSize(8);
            doc.setTextColor(30, 30, 30);
            doc.text(item.label, x + boxSize + 4, cursorY);
        }
        return cursorY + 6;
    };

    let cursorY = PAGE_MARGIN;

    if (routeAnalysisResult && typeof drawRouteAnalysisPDFPage === 'function') {
        drawRouteAnalysisPDFPage(doc, routeAnalysisResult);
        doc.addPage();
        cursorY = PAGE_MARGIN;
    }

    const now = new Date();
    const utc = now.toISOString().replace('T', ' ').substring(0, 19);
    
    doc.setFont("helvetica", "bold");
    doc.setFontSize(22);
    doc.setTextColor(30, 30, 30);
    doc.text("Aviation Weather Report", PAGE_WIDTH / 2, cursorY + 5, { align: "center" });
    
    doc.setFontSize(14);
    doc.text("METAR & TAF Details", PAGE_WIDTH / 2, cursorY + 12, { align: "center" });
    cursorY += 20;
    
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(`Generated (UTC): ${utc} Z`, PAGE_WIDTH / 2, cursorY + 5, { align: "center" });
    doc.text(`Total Stations: ${stationsData.length}`, PAGE_WIDTH / 2, cursorY + 10, { align: "center" });
    cursorY += 15;

    let sortDetail = "Sorted Alphabetically by Station ID";
    if (refName) sortDetail = `Sorted by Distance from ${refName}`;
    doc.text(sortDetail, PAGE_WIDTH / 2, cursorY, { align: "center" });
    
    cursorY += 10;
    cursorY = drawPdfLegend(doc, cursorY);
    
    doc.setDrawColor(220, 220, 220);
    doc.line(PAGE_MARGIN, cursorY, PAGE_WIDTH - PAGE_MARGIN, cursorY);
    cursorY += 6;

    for (const data of stationsData) {
        const stationId = data.id;
        const headerTitle = data.name ? `${stationId} - ${data.name}` : stationId;
        
        let metarLines = [];
        let metarColor = [0, 170, 0]; 
        let infoText = "";
        let infoTextParts = [];

        if (data.metar) {
            doc.setFont("courier", "normal");
            doc.setFontSize(9);
            try {
                metarLines = doc.splitTextToSize(data.metar.rawText || "", USABLE_WIDTH - 35);
            } catch(e) { metarLines = ["Error parsing METAR text"]; }

            if (typeof getCategoryColor === 'function') {
                metarColor = getCategoryColor(data.metar.category);
            }

            if(data.metar.tempF || data.metar.tempC) {
                 const tempStr = (typeof getDisplayTemp === 'function') ? getDisplayTemp(data.metar) : (data.metar.tempC + "¬∞C");
                 infoTextParts.push(`${tempStr} ‚Ä¢ ${data.metar.rh || ''}`);
            }
            if (data.metar.densityAlt) infoTextParts.push(data.metar.densityAlt);
            if (typeof formatAge === 'function' && data.metar.age != null) {
                infoTextParts.push(`Observed ${formatAge(data.metar.age)}`);
            }
            if (data.distanceNM !== null) infoTextParts.push(`${data.distanceNM.toFixed(0)} NM`);
            
            infoText = infoTextParts.join(' ‚Ä¢ ');

        } else if (data.distanceNM !== null) {
            infoText = `Distance: ${data.distanceNM.toFixed(0)} NM (No METAR)`;
        }

        // TAF Section
        let tafBlocks = [];
        let tafNotes = [];
        
        if (data.taf) {
            const raw = data.taf.rawText || "";
            // FIX: Apply same regex to keep PROB+TEMPO on same line
            const formatted = raw.replace(/\s(FM\d{6}|BECMG|PROB\d{2}\s+TEMPO|TEMPO|PROB\d{2})/g, "\n$1");
            const rawLines = formatted.split('\n').map(l => l.trim()).filter(l => l);
            
            let currentPrevailing = "";

            for (const line of rawLines) {
                const cleanLine = line.replace(/<[^>]*>?/gm, '');
                
                const isTempo = /^(TEMPO|PROB)/.test(cleanLine);
                const isBecmg = /^BECMG/.test(cleanLine);
                const isFm = /^FM/.test(cleanLine);
                
                let effectiveCondition = "";

                if (isFm) {
                    currentPrevailing = cleanLine;
                    effectiveCondition = currentPrevailing;
                } 
                else if (isBecmg) {
                    currentPrevailing = mergeCondition(currentPrevailing, cleanLine);
                    effectiveCondition = currentPrevailing;
                } 
                else if (isTempo) {
                    effectiveCondition = mergeCondition(currentPrevailing, cleanLine);
                } 
                else {
                    if (currentPrevailing === "") currentPrevailing = cleanLine;
                    else currentPrevailing = mergeCondition(currentPrevailing, cleanLine);
                    effectiveCondition = currentPrevailing;
                }

                let blockColor = [0, 170, 0];
                if (typeof analyzeCondition === 'function' && typeof getCategoryColor === 'function') {
                    blockColor = getCategoryColor(analyzeCondition(effectiveCondition));
                }

                tafBlocks.push({
                    lines: doc.splitTextToSize(line, USABLE_WIDTH - 35),
                    raw: line,
                    color: blockColor
                });
            }

            if (data.taf.periodHours !== null) tafNotes.push(`Forecast period ends in ${data.taf.periodHours} hours`);
            if (typeof formatAge === 'function' && data.taf.age !== null) tafNotes.push(`Issued ${formatAge(data.taf.age)}`);
        }

        // Layout Calculation
        doc.setFont("helvetica", "bold");
        doc.setFontSize(12);
        const headerLines = doc.splitTextToSize(headerTitle, USABLE_WIDTH);
        
        let heightNeeded = 3 + (headerLines.length * 6);
        if (infoText) heightNeeded += 6;
        if (metarLines.length > 0) heightNeeded += metarLines.length * LINE_SPACING + 3;
        if (tafBlocks.length > 0) {
            for (const block of tafBlocks) heightNeeded += block.lines.length * LINE_SPACING;
            heightNeeded += 5;
        }
        if (tafNotes.length > 0) heightNeeded += LINE_SPACING;

        if (cursorY + heightNeeded > PAGE_HEIGHT - PAGE_MARGIN - 10) {
            doc.addPage();
            cursorY = PAGE_MARGIN;
        }

        doc.setFont("helvetica", "bold");
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        headerLines.forEach(line => {
            doc.text(line, PAGE_MARGIN, cursorY);
            cursorY += 5;
        });

        if (infoText) {
            doc.setFont("helvetica", "normal");
            doc.setFontSize(10);
            doc.setTextColor(80, 80, 80);
            doc.text(infoText, PAGE_MARGIN, cursorY);
            cursorY += 6;
        } else { cursorY += 2; }

        if (data.metar) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            doc.text("METAR:", PAGE_MARGIN + 2, cursorY);
            for (const line of metarLines) {
                drawStyledText(doc, line, PAGE_MARGIN + 18, cursorY, metarColor);
                cursorY += LINE_SPACING;
            }
            cursorY += 2;
        }

        if (data.taf) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            doc.text("TAF:", PAGE_MARGIN + 2, cursorY);
            
            for (const block of tafBlocks) {
                for (const line of block.lines) {
                    drawStyledText(doc, line, PAGE_MARGIN + 18, cursorY, block.color);
                    cursorY += LINE_SPACING;
                }
            }
            cursorY += 2;
            
            if (tafNotes.length > 0) {
                doc.setFont("helvetica", "normal");
                doc.setFontSize(8);
                doc.setTextColor(100, 100, 100);
                doc.text(tafNotes.join(' ‚Ä¢ '), PAGE_MARGIN + 18, cursorY);
                cursorY += LINE_SPACING;
            }
        }

        doc.setDrawColor(220, 220, 220);
        doc.setLineWidth(0.1);
        doc.line(PAGE_MARGIN, cursorY, PAGE_WIDTH - PAGE_MARGIN, cursorY);
        cursorY += 6;
    }

    try {
        const pdfDataUri = doc.output('datauristring');
        const base64Data = pdfDataUri.substring(pdfDataUri.indexOf(',') + 1);
        
        if (window.Android && typeof window.Android.savePdf === 'function') {
            window.Android.savePdf(base64Data, "weather-report-combined.pdf");
        } else {
            const blob = doc.output('blob');
            const blobUrl = URL.createObjectURL(blob);
            window.open(blobUrl, '_blank');
        }
    } catch (e) {
        console.error('PDF export failed:', e);
        doc.save("weather-report-combined.pdf");
    }
}

// --- CUSTOM DASHBOARD FEATURE ---

let dashboardState = {
    stations: [], // List of ICAOs
    selectedRunways: {} // Map of ICAO -> selectedRunwayIndex
};

// Load saved data from storage
try {
    if (localStorage.dashboardState) {
        dashboardState = JSON.parse(localStorage.dashboardState);
    }
} catch(e) {}


function addDashboardStation() {
    const input = document.getElementById('dashInput');
    const icao = input.value.trim().toUpperCase();
    if (icao.length >= 3) {
        if (!dashboardState.stations.includes(icao)) {
            dashboardState.stations.push(icao);
            saveDashboardState();
            renderDashboard();
        }
        input.value = '';
    }
}

function removeDashboardStation(icao) {
    dashboardState.stations = dashboardState.stations.filter(s => s !== icao);
    delete dashboardState.selectedRunways[icao];
    saveDashboardState();
    renderDashboard();
}

function toggleStationRunway(icao) {
    if (!cachedRunwayMap || !cachedRunwayMap.has(icao)) return;
    const data = cachedRunwayMap.get(icao);
    if (!data.runways || data.runways.length === 0) return;

    const currentIdx = dashboardState.selectedRunways[icao] || 0;
    let nextIdx = currentIdx + 1;
    if (nextIdx >= data.runways.length) nextIdx = 0;

    dashboardState.selectedRunways[icao] = nextIdx;
    saveDashboardState();
}

function saveDashboardState() {
    try {
        localStorage.setItem('dashboardState', JSON.stringify(dashboardState));
    } catch(e) {}
}

let dashboardTimeOffset = 0;

function updateDashboardTime(val) {
    dashboardTimeOffset = parseInt(val);
    const label = document.getElementById('dashTimeLabel');
    const relLabel = document.getElementById('dashRelativeLabel');

    if (relLabel) relLabel.textContent = `+${dashboardTimeOffset}hr`;

    if (dashboardTimeOffset === 0) {
        if (label) label.textContent = "METAR";
    } else {
        const now = new Date();
        const targetTime = new Date(now.getTime() + (dashboardTimeOffset * 3600000));
        if (targetTime.getUTCMinutes() >= 30) {
            targetTime.setUTCHours(targetTime.getUTCHours() + 1);
        }
        targetTime.setUTCMinutes(0, 0, 0);
        const h = String(targetTime.getUTCHours()).padStart(2, '0');
        if (label) label.textContent = `${h}:00Z`;
    }
    renderDashboard();
}

function extractBriefConditions(rawText) {
    if (!rawText || rawText === 'No Data' || rawText === 'N/A') return "VFR / CLEAR";
    const clean = cleanRawText(rawText);
    const vis = clean.match(/\b(M)?(\d+(?:\/\d+)?)SM\b/);
    const clouds = clean.match(/\b(BKN|OVC|VV)\d{3}\b/g);
    const wxCodes = clean.match(/\b([-+]|VC)?(TS|RA|SN|DZ|FG|BR|HZ|FU|SQ|PL|GR|GS)\b/g);
    let parts = [];
    if (vis) parts.push(vis[0]);
    if (wxCodes) parts.push(wxCodes[0]);
    if (clouds) parts.push(clouds[0]);
    return parts.length > 0 ? parts.join(' ') : "VFR / CLEAR";
}

function getBestHeadwindRunwayIndex(icao, windDir, windSpeed) {
    if (!cachedRunwayMap || !cachedRunwayMap.has(icao)) return 0;
    const rwyData = cachedRunwayMap.get(icao);
    if (!rwyData.runways || rwyData.runways.length === 0) return 0;

    // Calculate metrics for all runways
    const candidates = rwyData.runways.map((rwy, idx) => {
        // If heading is missing, assume 0 (North) to prevent crash, but score poorly
        const heading = rwy.heading || 0; 
        
        const diff = Math.abs(windDir - heading) % 360;
        const rads = (diff * Math.PI) / 180;
        
        // Headwind: Positive is good. 
        const headwind = Math.cos(rads) * windSpeed;
        
        // Crosswind: Absolute value (closer to 0 is better)
        const crosswind = Math.abs(Math.sin(rads) * windSpeed);

        return {
            index: idx,
            headwind: headwind,
            crosswind: crosswind,
            length: rwy.length
        };
    });

    // Sort Candidates
    candidates.sort((a, b) => {
        // 1. Greatest Headwind (Higher is better)
        if (Math.abs(b.headwind - a.headwind) > 1.0) { // Increased tolerance slightly
            return b.headwind - a.headwind;
        }
        // 2. Smallest Crosswind (Lower is better)
        if (Math.abs(a.crosswind - b.crosswind) > 1.0) {
            return a.crosswind - b.crosswind;
        }
        // 3. Longest Runway (Higher is better)
        return b.length - a.length;
    });

    return candidates[0].index;
}

// NEW: Calculates the specific weather state at a target time
// Prioritizes TEMPO/PROB conditions if they are active at that moment.
function getConditionsAtTime(tafRawText, targetTime) {
    if (!tafRawText) return { category: 'NODATA', rawText: '' };
    
    // Parse Issue Time
    const tafValidMatch = tafRawText.match(/(\d{6})Z/);
    const now = new Date();
    let issueTime = new Date(now);
    if (tafValidMatch) {
        const day = parseInt(tafValidMatch[1].substring(0, 2));
        const hour = parseInt(tafValidMatch[1].substring(2, 4));
        issueTime = resolveTafDate(now, day, hour);
    }
    
    // Parse Blocks
    const blocks = parseTafToBlocks(tafRawText, issueTime);
    const t = targetTime.getTime();
    
    // 1. Build Prevailing State (All FM/BECMG lines leading up to time 't')
    const prevailingBlocks = blocks.filter(b => 
        (b.type === 'BASE' || b.type === 'CHANGE') && b.start <= t
    ).sort((a,b) => a.start - b.start);
    
    let activeState = "";
    prevailingBlocks.forEach(b => {
        if (b.type === 'BASE') activeState = b.text;
        else activeState = mergeCondition(activeState, b.text);
    });
    
    // 2. Apply TEMPO (If time 't' falls inside a TEMPO window)
    // We check for any active TEMPO and merge it on top. 
    // This forces TEMPO winds to override Prevailing winds.
    const activeTempo = blocks.find(b => 
        (b.type === 'TEMP') && b.start <= t && b.end >= t
    );
    
    if (activeTempo) {
        activeState = mergeCondition(activeState, activeTempo.text);
    }
    
    return {
        rawText: activeState,
        category: analyzeCondition(activeState)
    };
}

function renderDashboard() {
    const grid = document.getElementById('dashboardGrid');
    
    if (dashboardState.stations.length === 0) {
        grid.innerHTML = `
            <div class="col-span-full flex flex-col items-center justify-center p-12 text-center border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-3xl">
                <div class="text-5xl mb-4">üìç</div>
                <h3 class="text-xl font-bold text-gray-500">Dashboard is Empty</h3>
                <p class="text-gray-400 max-w-xs mt-2">Add an airport ICAO above to start monitoring live weather and forecasts.</p>
            </div>
        `;
        return;
    }

    grid.innerHTML = '';
    const stationLookup = new Map(allStationsData.map(s => [s.id, s]));

    dashboardState.stations.forEach(icao => {
        const station = stationLookup.get(icao) || { id: icao, metar: null, taf: null };
        let displayCat = 'NODATA', displayText = '', windDir = 0, windSpeed = 0, gustSpeed = 0, isExpired = false;
        let timeLabel = "----Z";

        const parseWind = (text) => {
            const match = text.match(/(\d{3}|VRB)(\d{2,3})(?:G(\d{2,3}))?KT/);
            if (match) {
                windDir = (match[1] === 'VRB') ? 0 : parseInt(match[1]);
                windSpeed = parseInt(match[2]);
                gustSpeed = match[3] ? parseInt(match[3]) : 0;
            }
        };

        if (dashboardTimeOffset === 0) {
            // LIVE METAR
            if (station.metar) { 
                displayCat = station.metar.category; 
                displayText = station.metar.rawText; 
                timeLabel = formatObsTime(station.metar.obsTime);
                parseWind(displayText); 
            }
        } else {
            // FORECAST TAF
            if (station.taf) {
                const target = new Date(new Date().getTime() + (dashboardTimeOffset * 3600000));
                
                // --- FIX: Round to nearest hour ---
                if (target.getUTCMinutes() >= 30) {
                    target.setUTCHours(target.getUTCHours() + 1);
                }
                target.setUTCMinutes(0, 0, 0);
                // ----------------------------------

                timeLabel = `${String(target.getUTCHours()).padStart(2,'0')}00Z`;
                
                if (station.taf.validTo && target > station.taf.validTo) isExpired = true;
                
                const condition = getConditionsAtTime(station.taf.rawText, target);
                
                displayCat = isExpired ? 'NODATA' : condition.category; 
                displayText = condition.rawText; 
                parseWind(displayText);
            } else {
                isExpired = true;
            }
        }

        const rwyIdx = getBestHeadwindRunwayIndex(icao, windDir, windSpeed);
        dashboardState.selectedRunways[icao] = rwyIdx;
        const selectedRwyID = cachedRunwayMap?.get(icao)?.runways[rwyIdx]?.id || "--";

        const tileClass = isExpired ? 'nodata-tile' : getCategoryTileClassName(displayCat);
        const card = document.createElement('div');
        card.className = `${tileClass} text-white p-2 rounded-xl flex flex-col items-center gap-1 cursor-pointer relative shadow-lg transition-all border-b-4 border-black/30 group`;
        card.onclick = () => openDashDetail(icao);

        card.innerHTML = `
            <div class="w-full flex justify-between items-start font-mono z-10">
                <div class="flex flex-col">
                    <span class="text-xl font-black tracking-tighter leading-none">${icao}</span>
                    <span class="text-[8px] font-bold opacity-80">RWY ${selectedRwyID} ${isExpired ? '‚Ä¢ <span class="text-red-300">EXPIRED</span>' : ''}</span>
                </div>
                <button onclick="event.stopPropagation(); removeDashboardStation('${icao}')" 
                        class="p-0.5 rounded-full hover:bg-red-500 text-white/50 hover:text-white transition-all">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="3" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>

            <div class="flex-1 w-full flex items-center justify-center py-1">
                ${generateRunwaySVG(icao, windDir, windSpeed, gustSpeed, isExpired, 80)}
            </div>

            <div class="w-full mt-auto space-y-1">
                <div class="text-[9px] font-black text-center bg-black/20 rounded py-0.5">
                    ${isExpired ? 'TAF EXPIRED' : `${windDir.toString().padStart(3,'0')}@${windSpeed}${gustSpeed ? `G${gustSpeed}` : ''}KT`}
                </div>
                <div class="text-[8px] font-bold font-mono leading-tight bg-black/40 rounded-md py-1 px-1 border border-white/10 text-center truncate">
                    ${isExpired ? 'No Valid Forecast' : extractBriefConditions(displayText)}
                </div>
            </div>
        `;
        grid.appendChild(card);
    });
}

function jumpToMapFromModal(icao) {
    // 1. Close Modal
    closeTileModal();
    
    // 2. Switch to Map Tab
    switchTab('map');
    
    // 3. Find Coords and Fly
    const station = allStationsData.find(s => s.id === icao);
    if (station && station.latitude && station.longitude && mapInstance) {
        // Fly to location
        mapInstance.flyTo([station.latitude, station.longitude], 12, {
            animate: true,
            duration: 1.5
        });
        
        // Optional: Open the map popup after arrival
        setTimeout(() => {
            markerLayerGroup.eachLayer(layer => {
                if (layer.stationId === icao && layer.openPopup) {
                    layer.openPopup();
                }
            });
        }, 1600);
    }
}

function openDashDetail(icao, forceLive = false, preserveSelection = false) {
    const stationLookup = new Map(allStationsData.map(s => [s.id, s]));
    const station = stationLookup.get(icao) || { id: icao, metar: null, taf: null };

    let windDir = 0, windSpeed = 0, gustSpeed = 0, isExpired = false;
    let targetTime = new Date();
    let displayCat = 'VFR';
    let timeLabel = "----Z";

    // Variables for UI
    let tempStr = "--", dewStr = "--", rhStr = "--", daStr = "--", flightCat = "NODATA";
    let feelsLikeHtml = "";
    
    // Flag to control visibility of the "Current Conditions" box
    let showLiveStats = false; 

    const parseWind = (text) => {
        if (!text) return;
        const match = text.match(/(\d{3}|VRB)(\d{2,3})(?:G(\d{2,3}))?KT/);
        if (match) {
            windDir = (match[1] === 'VRB') ? 0 : parseInt(match[1]);
            windSpeed = parseInt(match[2]);
            gustSpeed = match[3] ? parseInt(match[3]) : 0;
        }
    };

    const effectiveOffset = forceLive ? 0 : dashboardTimeOffset;

    // 1. Determine Conditions based on Time Mode
    if (effectiveOffset > 0) {
        // --- FORECAST MODE ---
        targetTime = new Date(new Date().getTime() + (effectiveOffset * 3600000));
        if (targetTime.getUTCMinutes() >= 30) targetTime.setUTCHours(targetTime.getUTCHours() + 1);
        targetTime.setUTCMinutes(0, 0, 0);

        timeLabel = `${String(targetTime.getUTCHours()).padStart(2,'0')}00Z (Forecast)`;
        
        if (station.taf) {
            const condition = getConditionsAtTime(station.taf.rawText, targetTime);
            
            displayCat = condition.category;
            flightCat = displayCat; 
            
            parseWind(condition.rawText);
            
            if (station.taf.validTo && targetTime > station.taf.validTo) isExpired = true;
        }
    } else {
        // --- LIVE MODE ---
        showLiveStats = true; 
        
        displayCat = station.metar?.category || 'VFR';
        if (station.metar) {
            parseWind(station.metar.rawText);
            timeLabel = `${formatObsTime(station.metar.obsTime)} (Observed)`;
            
            // Populate Live Data
            tempStr = getDisplayTemp(station.metar);
            const dewc = station.metar.rawDewC;
            dewStr = (dewc !== null) ? (useCelsius ? `${Math.round(dewc)}¬∞C` : `${Math.round(dewc * 1.8 + 32)}¬∞F`) : "--";
            rhStr = station.metar.rh;
            daStr = station.metar.densityAlt || "--";
            flightCat = station.metar.category || "NODATA";

            if (station.metar.feelsLike) {
                const flVal = useCelsius ? `${station.metar.feelsLike.c}¬∞` : `${station.metar.feelsLike.f}¬∞`;
                const flLabel = station.metar.feelsLike.label;
                const flColor = flLabel === 'Wind Chill' ? 'text-cyan-300' : 'text-orange-300';
                feelsLikeHtml = `<div class="bg-white/10 px-2 py-0.5 rounded text-[10px] font-bold uppercase ${flColor} border border-white/10 ml-auto">${flLabel} ${flVal}</div>`;
            }
        }
    }

    // 2. Logic to Force Best Runway Selection on Entry
    const effectiveSpeed = Math.max(windSpeed, gustSpeed);
    if (cachedRunwayMap && cachedRunwayMap.has(icao)) {
        if (!preserveSelection || dashboardState.selectedRunways[icao] === undefined) {
             const bestIdx = getBestHeadwindRunwayIndex(icao, windDir, effectiveSpeed);
             dashboardState.selectedRunways[icao] = bestIdx;
        }
    }

    // 3. Generate Selector Buttons
    let runwaySelectorHtml = '';
    if (cachedRunwayMap && cachedRunwayMap.has(icao)) {
        const rwyData = cachedRunwayMap.get(icao);
        const selectedIdx = dashboardState.selectedRunways[icao] || 0;
        runwaySelectorHtml = `<div class="flex flex-wrap gap-2 justify-center mt-6 relative z-30 pointer-events-auto">`;
        rwyData.runways.forEach((r, idx) => {
            const isActive = (idx === selectedIdx);
            const btnClass = isActive 
                ? "bg-indigo-600 text-white border-indigo-400 shadow-lg scale-105" 
                : "bg-white/10 text-gray-400 border-transparent hover:bg-white/20";
            runwaySelectorHtml += `
                <button onclick="event.stopPropagation(); selectDashRunway('${icao}', ${idx}, ${forceLive})"
                        class="px-4 py-1.5 rounded-full text-xs font-bold font-mono border transition-all cursor-pointer ${btnClass}">
                    ${r.id}
                </button>
            `;
        });
        runwaySelectorHtml += `</div>`;
    } else {
        runwaySelectorHtml = `<div class="mt-6 text-xs text-gray-500 italic text-center">No runway data available</div>`;
    }

    // 4. Build Live Stats HTML Block (2x2 Grid)
    let liveStatsBlock = '';
    if (showLiveStats) {
        const cleanRh = rhStr.replace(/^RH\s+/, '');
        const cleanDa = daStr.replace(/^DA\s+/, '');
        
        liveStatsBlock = `
            <div class="bg-black/30 p-3 rounded-xl border border-white/10 flex-1 flex flex-col justify-center min-h-[140px]">
                <div class="flex items-center mb-3">
                    <span class="text-[10px] font-black uppercase opacity-60 tracking-wider">Current Conditions</span>
                    ${feelsLikeHtml}
                </div>
                <div class="grid grid-cols-2 gap-2 text-center h-full">
                    <div class="bg-white/5 rounded-lg p-2 flex flex-col justify-center items-center">
                        <span class="text-[9px] uppercase opacity-60 leading-none mb-1">Temp</span>
                        <span class="font-bold text-lg leading-none">${tempStr}</span>
                    </div>
                    <div class="bg-white/5 rounded-lg p-2 flex flex-col justify-center items-center">
                        <span class="text-[9px] uppercase opacity-60 leading-none mb-1">Dewpoint</span>
                        <span class="font-bold text-lg leading-none">${dewStr}</span>
                    </div>
                    <div class="bg-white/5 rounded-lg p-2 flex flex-col justify-center items-center">
                        <span class="text-[9px] uppercase opacity-60 leading-none mb-1">Humidity</span>
                        <span class="font-mono font-bold text-lg leading-none">${cleanRh}</span>
                    </div>
                    <div class="bg-white/5 rounded-lg p-2 flex flex-col justify-center items-center">
                        <span class="text-[9px] uppercase opacity-60 leading-none mb-1">Density Alt</span>
                        <span class="font-mono font-bold text-lg leading-none whitespace-nowrap">${cleanDa}</span>
                    </div>
                </div>
            </div>
        `;
    }

    const modal = document.getElementById('tileModal');
    const container = modal.querySelector('div');
    const tileClass = isExpired ? 'nodata-tile' : getCategoryTileClassName(displayCat);

    container.className = `rounded-3xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col modal-enter overflow-hidden ${tileClass} text-white`;
    container.innerHTML = `
        <div class="p-6 overflow-y-auto custom-scrollbar font-sans">
            <!-- Header -->
            <div class="flex justify-between items-start mb-4">
                <div>
                    <h2 class="text-6xl font-black font-mono tracking-tighter drop-shadow-lg leading-none">${icao}</h2>
                    <p class="text-lg font-bold opacity-80 uppercase truncate max-w-[200px] sm:max-w-md">${station.name || ''}</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="jumpToMapFromModal('${icao}')" class="p-3 bg-blue-600 hover:bg-blue-500 rounded-full transition-colors shadow-lg z-50 text-white" title="View on Map">
                         <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 7m0 13V7" />
                        </svg>
                    </button>
                    <button onclick="closeTileModal()" class="p-3 bg-black/20 hover:bg-black/40 rounded-full transition-colors z-50">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="4" d="M6 18L18 6M6 6l12 12"/></svg>
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Runway Visualizer Card -->
                <div class="bg-black/30 rounded-3xl p-8 flex flex-col items-center border border-white/20 shadow-inner relative overflow-visible min-h-[300px] justify-center">
                    ${generateRunwaySVG(icao, windDir, windSpeed, gustSpeed, isExpired, 180)}
                    ${runwaySelectorHtml}
                </div>
                
                <!-- Stats Column -->
                <div class="flex flex-col gap-4">
                    <div class="flex gap-4">
                        <div class="bg-black/30 p-4 rounded-2xl border border-white/10 flex-1">
                            <span class="text-[9px] font-black uppercase opacity-60 block mb-1">Wind</span>
                            <div class="text-2xl font-mono font-black">${windDir.toString().padStart(3,'0')}@${windSpeed}${gustSpeed ? `G${gustSpeed}` : ''}</div>
                        </div>
                        <div class="bg-black/30 p-4 rounded-2xl border border-white/10 flex-1">
                             <span class="text-[9px] font-black uppercase opacity-60 block mb-1">Flight Cat</span>
                             <div class="text-2xl font-black">${flightCat}</div>
                        </div>
                    </div>

                    ${liveStatsBlock}

                    <div class="bg-black/30 p-3 rounded-2xl border border-white/10">
                        <span class="text-[9px] font-black uppercase opacity-60">Valid Time</span>
                        <div class="text-xs font-mono font-bold uppercase">${timeLabel}</div>
                    </div>
                </div>
            </div>

            <!-- Text Data -->
            <div class="space-y-4">
                <div class="bg-black/20 p-4 rounded-xl">
                    <h3 class="text-[10px] font-black uppercase tracking-widest opacity-60 mb-2">METAR</h3>
                    <div class="font-mono text-sm leading-relaxed">
                        ${station.metar ? formatRawText(station.metar.rawText) : '<p class="italic opacity-40">No data</p>'}
                    </div>
                </div>
                <div class="bg-black/20 p-4 rounded-xl">
                    <h3 class="text-[10px] font-black uppercase tracking-widest opacity-60 mb-2">TAF (Time Synced)</h3>
                    <div class="space-y-1">
                        ${station.taf ? formatAnalyzedTaf(station.taf.rawText, targetTime, new Date(targetTime.getTime() + 1800000)) : '<p class="italic opacity-40">No data</p>'}
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.style.overflow = 'hidden';
    modal.classList.remove('hidden');
}

// [UPDATED] Helper for Map Popups - Ensures data exists before opening
async function openMapDetail(icao) {
    // 1. Ensure Runway Data is loaded (it might be missing if user hasn't opened Dashboard yet)
    if (!cachedRunwayMap) {
        // Change cursor to wait to indicate loading
        document.body.style.cursor = 'wait';
        try {
            await getRunwayData();
        } catch (e) {
            console.error("Failed to load runway data", e);
        } finally {
            document.body.style.cursor = 'default';
        }
    }
    
    // 2. Open the detail view in "Force Live" mode
    openDashDetail(icao, true);
}

function selectDashRunway(icao, index, forceLive = false) {
    // 1. Save the selection to state
    if (!dashboardState.selectedRunways) dashboardState.selectedRunways = {};
    dashboardState.selectedRunways[icao] = index;
    saveDashboardState();
    
    // 2. Refresh the modal view immediately, PRESERVING the selection we just made
    openDashDetail(icao, forceLive, true);
    
    // 3. Refresh background
    renderDashboard();
    if (typeof showRunwaysOnMap !== 'undefined' && showRunwaysOnMap) {
        renderMap(currentStationsData);
    }
}


function generateRunwaySVG(icao, windDir, windSpeed, gustSpeed, isExpired, size = 100, overrideRwyIndex = -1) {
    // 1. Validation
    if (!cachedRunwayMap || !cachedRunwayMap.has(icao)) {
        if(size < 60) return `<div style="width:${size}px;height:${size}px;background:#888;border-radius:50%;"></div>`;
        return `<div class="opacity-30 font-bold text-xs font-mono">NO DATA</div>`;
    }
    
    const rwyData = cachedRunwayMap.get(icao);
    if (!rwyData.runways || rwyData.runways.length === 0) return "";

    // 2. Selection Logic
    let bestRwyIdx = 0;
    if (overrideRwyIndex !== -1) {
        bestRwyIdx = overrideRwyIndex;
    } else {
        bestRwyIdx = dashboardState.selectedRunways[icao] || 0;
    }
    // Safety check
    if (bestRwyIdx >= rwyData.runways.length) bestRwyIdx = 0;
    
    const bestRwy = rwyData.runways[bestRwyIdx];

    // 3. Crosswind Calc
    const effectiveSpeed = Math.max(windSpeed, gustSpeed);
    const diff = Math.abs(windDir - bestRwy.heading) % 360;
    const rads = (diff * Math.PI) / 180;
    const hw = Math.round(Math.cos(rads) * effectiveSpeed);
    const xw = Math.round(Math.sin(rads) * effectiveSpeed);

    // 4. Projection Logic
    let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
    let hasCoords = false;

    rwyData.runways.forEach(r => {
        if (r.leLat && r.leLon && r.heLat && r.heLon) {
            minLat = Math.min(minLat, r.leLat, r.heLat);
            maxLat = Math.max(maxLat, r.leLat, r.heLat);
            minLon = Math.min(minLon, r.leLon, r.heLon);
            maxLon = Math.max(maxLon, r.leLon, r.heLon);
            hasCoords = true;
        }
    });

    if (!hasCoords) return `<div class="opacity-30 font-bold text-[9px] font-mono text-center">NO GEO</div>`;

    const paddingLat = (maxLat - minLat) * 0.05; 
    const paddingLon = (maxLon - minLon) * 0.05;
    
    if (paddingLat === 0) { minLat -= 0.005; maxLat += 0.005; } else { minLat -= paddingLat; maxLat += paddingLat; }
    if (paddingLon === 0) { minLon -= 0.005; maxLon += 0.005; } else { minLon -= paddingLon; maxLon += paddingLon; }

    const latRange = maxLat - minLat;
    const lonRange = maxLon - minLon;
    const centerLat = (minLat + maxLat) / 2;
    const lonCorrection = Math.cos(centerLat * Math.PI / 180);
    const correctedLonRange = lonRange * lonCorrection;
    const maxDimension = Math.max(latRange, correctedLonRange);
    const scale = 100 / maxDimension;

    const project = (lat, lon) => {
        const x = ((lon - minLon) * lonCorrection) * scale + (50 - (correctedLonRange * scale / 2));
        const y = 100 - (((lat - minLat) * scale) + (50 - (latRange * scale / 2)));
        return { x, y };
    };

    // 5. Draw Runways
    let runwaysHtml = '';
    const drawnKeys = new Set();
    const renderQueue = [];

    rwyData.runways.forEach(r => {
        const key = [r.leLat, r.leLon, r.heLat, r.heLon].sort().join(',');
        if (drawnKeys.has(key)) return;
        
        const isActiveStrip = (r.leLat === bestRwy.leLat && r.leLon === bestRwy.leLon) || 
                              (r.leLat === bestRwy.heLat && r.leLon === bestRwy.heLon);
        
        if (isActiveStrip) renderQueue.push({ r, active: true }); 
        else renderQueue.unshift({ r, active: false });
        drawnKeys.add(key);
    });

    renderQueue.forEach(item => {
        const r = item.r;
        const isActive = item.active;
        const start = project(r.leLat, r.leLon);
        const end = project(r.heLat, r.heLon);
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const opacity = isActive ? "1.0" : "0.5";
        const baseWidth = 14; 
        const asphaltWidth = 12; 
        const thresholdLen = 6;
        const numberOffset = 12;
        const idLow = r.id; 
        const idHigh = r.oppId || '';

        runwaysHtml += `
        <g transform="translate(${midX}, ${midY}) rotate(${angle})" opacity="${opacity}">
            <rect x="${-len/2 - 1}" y="${-baseWidth/2}" width="${len + 2}" height="${baseWidth}" fill="white" />
            <rect x="${-len/2}" y="${-asphaltWidth/2}" width="${len}" height="${asphaltWidth}" fill="#1e293b" />
            <line x1="${-len/2 + 15}" y1="0" x2="${len/2 - 15}" y2="0" stroke="white" stroke-width="1" stroke-dasharray="4,3" />
            <g stroke="white" stroke-width="1">
                <line x1="${-len/2 + 2}" y1="${-asphaltWidth/2 + 2}" x2="${-len/2 + thresholdLen}" y2="${-asphaltWidth/2 + 2}" />
                <line x1="${-len/2 + 2}" y1="${-asphaltWidth/2 + 4}" x2="${-len/2 + thresholdLen}" y2="${-asphaltWidth/2 + 4}" />
                <line x1="${-len/2 + 2}" y1="${asphaltWidth/2 - 2}" x2="${-len/2 + thresholdLen}" y2="${asphaltWidth/2 - 2}" />
                <line x1="${-len/2 + 2}" y1="${asphaltWidth/2 - 4}" x2="${-len/2 + thresholdLen}" y2="${asphaltWidth/2 - 4}" />
                <line x1="${len/2 - 6}" y1="${-asphaltWidth/2 + 2}" x2="${len/2 - 2}" y2="${-asphaltWidth/2 + 2}" />
                <line x1="${len/2 - 6}" y1="${-asphaltWidth/2 + 4}" x2="${len/2 - 2}" y2="${-asphaltWidth/2 + 4}" />
                <line x1="${len/2 - 6}" y1="${asphaltWidth/2 - 2}" x2="${len/2 - 2}" y2="${asphaltWidth/2 - 2}" />
                <line x1="${len/2 - 6}" y1="${asphaltWidth/2 - 4}" x2="${len/2 - 2}" y2="${asphaltWidth/2 - 4}" />
            </g>
            <text x="${-len/2 + numberOffset}" y="0" fill="#e2e8f0" font-family="monospace" font-weight="bold" font-size="5" text-anchor="middle" dominant-baseline="middle" transform="rotate(90, ${-len/2 + numberOffset}, 0)">${idLow}</text>
            <text x="${len/2 - numberOffset}" y="0" fill="#e2e8f0" font-family="monospace" font-weight="bold" font-size="5" text-anchor="middle" dominant-baseline="middle" transform="rotate(-90, ${len/2 - numberOffset}, 0)">${idHigh}</text>
        </g>`;
    });

    // 6. Wind Arrow
    const arrowRot = windDir; 
    const windHtml = (!isExpired && effectiveSpeed > 1) ? `
        <g transform="rotate(${arrowRot}, 50, 50)">
            <line x1="50" y1="10" x2="50" y2="90" stroke="black" stroke-width="5" stroke-linecap="round" opacity="0.3" />
            <line x1="50" y1="10" x2="50" y2="90" stroke="${effectiveSpeed > 15 ? '#ef4444' : '#fbbf24'}" stroke-width="2.5" stroke-linecap="round" />
            <path d="M50 90 L55 80 L45 80 Z" fill="black" opacity="0.3" transform="translate(0, 2)" />
            <path d="M50 90 L55 80 L45 80 Z" fill="${effectiveSpeed > 15 ? '#ef4444' : '#fbbf24'}" stroke="white" stroke-width="0.5" />
        </g>
    ` : '';

    // 7. Pill Logic (Updated for Dashboard)
    const showPill = size > 60; 
    // Scale text based on size
    const fontSize = size < 100 ? "text-[8px]" : "text-[10px]";
    const padding = size < 100 ? "px-2 py-px" : "px-3 py-0.5";
    const bottomPos = size < 100 ? "-bottom-1" : "-bottom-2";

    return `
        <div class="relative flex flex-col items-center justify-center bg-transparent" style="width: ${size}px; height: ${size}px;">
            <svg viewBox="0 0 100 100" class="w-full h-full overflow-visible drop-shadow-xl" style="background: transparent;">
                <text x="50" y="4" font-size="5" fill="#64748b" text-anchor="middle" font-family="monospace" opacity="0.7">N</text>
                ${runwaysHtml}
                ${windHtml}
            </svg>
            ${showPill ? `
            <div class="absolute ${bottomPos} bg-slate-900 border-2 border-indigo-500/50 ${padding} rounded-full ${fontSize} font-black font-mono text-white shadow-2xl z-20 whitespace-nowrap">
                ${isExpired ? '---' : `H:${hw} X:${Math.abs(xw)}`}
            </div>` : ''}
        </div>
    `;
}

// --- RECORDS / EXTREMES LOGIC ---

function closeRecordsModal() {
    document.getElementById('recordsModal').classList.add('hidden');
    document.body.style.overflow = '';
}

function showRecords() {
    if (!allStationsData || allStationsData.length === 0) {
        alert("No station data loaded yet.");
        return;
    }

    const records = calculateExtremes();
    const grid = document.getElementById('recordsGrid');
    document.getElementById('recordsCount').textContent = allStationsData.length.toLocaleString();
    
    grid.innerHTML = ''; // Clear existing

    // Helper to build a card
    const createCard = (title, icon, data, colorClass, subText = "") => {
        if (!data.station) return;
        const station = data.station;
        // Use existing color logic or default to gray
        const catColor = COLORS[station.metar?.category] ? rgbToHex(COLORS[station.metar.category]) : '#6b7280';
        
        return `
            <div class="bg-white dark:bg-gray-800 rounded-xl p-4 shadow-sm border border-gray-200 dark:border-gray-700 hover:shadow-lg hover:scale-[1.02] transition-all cursor-pointer group relative overflow-hidden"
                 onclick="closeRecordsModal(); openDashDetail('${station.id}', true)">
                
                <!-- Color Bar -->
                <div class="absolute top-0 left-0 w-1.5 h-full" style="background-color: ${catColor}"></div>

                <div class="flex justify-between items-start mb-2 pl-3">
                    <div class="flex items-center gap-2">
                        <span class="text-2xl">${icon}</span>
                        <span class="text-sm font-bold text-gray-500 dark:text-gray-400 uppercase tracking-wider">${title}</span>
                    </div>
                    <span class="font-mono font-black text-xl text-gray-900 dark:text-white">${station.id}</span>
                </div>

                <div class="pl-3 mt-2">
                    <div class="text-3xl font-black text-gray-800 dark:text-gray-100 ${colorClass}">
                        ${data.displayVal}
                    </div>
                    ${subText ? `<div class="text-xs font-bold text-gray-400 mt-1 font-mono">${subText}</div>` : ''}
                    <div class="text-xs text-gray-500 mt-2 truncate">${station.name}</div>
                </div>
            </div>
        `;
    };

    let html = '';

    // 1. Highest Wind
    html += createCard("Highest Wind", "üí®", records.wind, "text-blue-600 dark:text-blue-400", records.wind.sub);
    
    // 2. Highest Crosswind
    html += createCard("Max Crosswind", "‚úàÔ∏è", records.xwind, "text-indigo-600 dark:text-indigo-400", records.xwind.sub);
    
    // 3. Hottest
    html += createCard("Hottest Temp", "üî•", records.hot, "text-red-500", "");
    
    // 4. Coldest
    html += createCard("Coldest Temp", "‚ùÑÔ∏è", records.cold, "text-cyan-500", "");
    
    // 5. Highest Dewpoint
    html += createCard("Highest Dewpoint", "üíß", records.dew, "text-green-500", `Feels muggy`);

    grid.innerHTML = html;

    document.getElementById('recordsModal').classList.remove('hidden');
    document.body.style.overflow = 'hidden';
}

function calculateExtremes() {
    let rec = {
        wind: { val: -1, station: null, displayVal: "0 KT", sub: "" },
        xwind: { val: -1, station: null, displayVal: "0 KT", sub: "" },
        hot: { val: -999, station: null, displayVal: "" },
        cold: { val: 999, station: null, displayVal: "" },
        dew: { val: -999, station: null, displayVal: "" }
    };

    allStationsData.forEach(s => {
        if (!s.metar) return;

        // --- TEMPERATURE ---
        // Using rawTempC from data processing
        const t = s.metar.rawTempC;
        if (t !== null && !isNaN(t)) {
            if (t > rec.hot.val) {
                rec.hot = { 
                    val: t, 
                    station: s, 
                    displayVal: `${t}¬∞C` 
                };
            }
            if (t < rec.cold.val) {
                rec.cold = { 
                    val: t, 
                    station: s, 
                    displayVal: `${t}¬∞C` 
                };
            }
        }

        // --- DEWPOINT ---
        const d = s.metar.rawDewC;
        if (d !== null && !isNaN(d)) {
            if (d > rec.dew.val) {
                rec.dew = { 
                    val: d, 
                    station: s, 
                    displayVal: `${d}¬∞C` 
                };
            }
        }

        // --- WIND & CROSSWIND ---
        // We must re-parse raw text to get Gusts accurately, 
        // as s.metar.windSpeed usually only stores sustained.
        const match = s.metar.rawText.match(/(\d{3}|VRB)(\d{2,3})(?:G(\d{2,3}))?KT/);
        if (match) {
            const dirStr = match[1];
            const spd = parseInt(match[2]);
            const gust = match[3] ? parseInt(match[3]) : 0;
            const maxWind = Math.max(spd, gust);

            // Check Highest Overall Wind
            if (maxWind > rec.wind.val) {
                rec.wind = {
                    val: maxWind,
                    station: s,
                    displayVal: `${maxWind} KT`,
                    sub: gust > 0 ? `Gusts ${gust} KT` : 'Sustained'
                };
            }

            // Check Highest Crosswind
            // Only calculate if we have runway data and wind direction is numeric
            if (cachedRunwayMap && cachedRunwayMap.has(s.id) && dirStr !== 'VRB') {
                const windDir = parseInt(dirStr);
                const rwyData = cachedRunwayMap.get(s.id);
                
                let maxXwForStation = 0;
                let worstRwy = "";

                if (rwyData.runways) {
                    rwyData.runways.forEach(r => {
                        const diff = Math.abs(windDir - r.heading) % 360;
                        const rads = (diff * Math.PI) / 180;
                        const xw = Math.abs(Math.sin(rads) * maxWind); // Use Max Wind (Gusts included) for XW
                        
                        if (xw > maxXwForStation) {
                            maxXwForStation = xw;
                            worstRwy = r.id;
                        }
                    });
                }

                if (maxXwForStation > rec.xwind.val) {
                    rec.xwind = {
                        val: maxXwForStation,
                        station: s,
                        displayVal: `${Math.round(maxXwForStation)} KT`,
                        sub: `RWY ${worstRwy}`
                    };
                }
            }
        }
    });

    // Formatting for F/C toggle support could be added here, 
    // currently sticking to C as per raw data for simplicity.
    if (useCelsius === false) {
        if(rec.hot.val !== -999) rec.hot.displayVal = `${Math.round(rec.hot.val * 1.8 + 32)}¬∞F`;
        if(rec.cold.val !== 999) rec.cold.displayVal = `${Math.round(rec.cold.val * 1.8 + 32)}¬∞F`;
        if(rec.dew.val !== -999) rec.dew.displayVal = `${Math.round(rec.dew.val * 1.8 + 32)}¬∞F`;
    }

    return rec;
}

// Start the 1-minute timer immediately on load
startAutoRefresh();

</script>
</body>
</html>    
